# Medium

## 3 Sum

### Brute force approach

```java
class Solution {
    public List<List<Integer>> threeSum(int[] nums) {
        Set<List<Integer>> ans = new HashSet<>();

        for(int i = 0; i < nums.length-2; i++) {
            for(int j =i+1; j < nums.length-1; j++) {
                for(int k = j+1; k < nums.length; k++) {
                    if(i!=j && j!= k && i!=k) {
                        if(nums[i] + nums[j] + nums[k]==0) {
                            List<Integer> t = new ArrayList<>();
                            t.add(nums[i]);
                            t.add(nums[j]);
                            t.add(nums[k]);

                            Collections.sort(t);
                            ans.add(t);
                        }
                    }
                }
            }
        }
        return new ArrayList<>(ans);
    }
}
```

- Edge cases
  1. Sorting the inner array
  2. All the inner arrays should be unique

### Level 1 optimized

- a[k]= -(a[i] + a[j])
- Hashing

```java
class Solution {
    public List<List<Integer>> threeSum(int[] nums) {
        int n = nums.length;
        Set<List<Integer>> ans = new HashSet<>();
        for(int i = 0; i < n -1; i++) {
            HashSet<Integer> set = new HashSet<>();
            for(int j = i+1; j < n; j++) {
                List<Integer> temp = new ArrayList<>();
                if(set.contains(-(nums[i] + nums[j]))) {
                    temp.add(nums[i]);
                    temp.add(nums[j]);
                    temp.add(-(nums[i] + nums[j]));
                    Collections.sort(temp);
                    ans.add(temp);
                } else {
                    set.add(nums[j]);
                }
            }
        }
        return new ArrayList<>(ans);
    }
}
```

### Level 2

- Instead of sorting and temp array, sort the main array
- skipping the used values

```java title="Optimized"
class Solution {
    public List<List<Integer>> threeSum(int[] nums) {
        List<List<Integer>> ans = new ArrayList<>();
        Arrays.sort(nums);
        int n = nums.length;
        for(int i = 0; i < n - 2; i++) {
            if (i > 0 && nums[i] == nums[i - 1]) continue;
            int j = i+1;
            int k = n-1;
            while(j < k) {
                if(nums[i] + nums[j] + nums[k]==0) {
                    ans.add(Arrays.asList(nums[i], nums[j], nums[k]));
                    j++;
                    k--;
                    while(j < k && nums[j]==nums[j-1]) j++;
                    while(j < k && nums[k]==nums[k+1]) k--;
                } else if((nums[i] + nums[j] + nums[k] > 0)) {
                    k--;
                } else {
                    j++;
                }
            }
        }
        return ans;
    }
}
```

## Sort an array of 0s, 1s, 2s

```java
class Solution {
    public void sortZeroOneTwo(int[] nums) {
        int low = 0, high = nums.length-1;
        int mid = 0;
        while(mid <= high) {
            if(nums[mid] == 0) {
                swap(nums, low, mid);
                mid++;low++;
            } else if(nums[mid] == 1) {
                mid++;
            } else {
                swap(nums, mid, high);
                high--;
            }
        }
    }

    public void swap(int[] nums, int i, int j) {
        int temp = nums[i];
        nums[i] = nums[j];
        nums[j] = temp;
    }
}
```

- "Use three pointers (low, mid, and high) to partition the array into three
  regions: Elements less than 1 (0) are moved to the left (region of 0s).
  Elements equal to 1 are in the middle. Elements greater than 1 (2) are moved
  to the right (region of 2s)."
- "If the element at mid is 0, swap it with the element at low and move both
  pointers forward. If the element at mid is 1, move the mid pointer forward. If
  the element at mid is 2, swap it with the element at high and move high
  backward."
