---
sidebar_position: 19
---
# Advanced Query Optimization
Optimizing queries is essential for improving **performance, reducing execution time, and avoiding unnecessary resource usage**. PostgreSQL provides **query execution plans, indexing strategies, and optimizer techniques** to speed up queries.  

---

## **1ï¸âƒ£ Understanding Query Execution Plans (`EXPLAIN ANALYZE`)**  
âœ” `EXPLAIN ANALYZE` **shows how PostgreSQL executes a query** and provides performance insights.  

âœ… **Example Query Execution Plan:**  
```sql
EXPLAIN ANALYZE SELECT * FROM orders WHERE customer_id = 5;
```

ğŸš€ **Key Terms in Query Plans:**  
| Term                  | Meaning |
|----------------------|---------|
| **Seq Scan (Sequential Scan)** | Scans the entire table (slow) |
| **Index Scan** | Uses an index (faster) |
| **Bitmap Index Scan** | Uses an index for large result sets (efficient) |
| **Nested Loop Join** | Efficient for small datasets |
| **Hash Join** | Faster for large datasets |
| **Sort** | Sorting data in memory |
| **Parallel Query Execution** | Uses multiple CPU cores |

---

## **2ï¸âƒ£ Optimizing Index Usage**  
âœ” **Indexing prevents slow sequential scans (`Seq Scan`)**.  
âœ” **Use `EXPLAIN ANALYZE` to confirm index usage**.  

âœ… **Step 1: Create an Index**  
```sql
CREATE INDEX idx_orders_customer ON orders(customer_id);
```

âœ… **Step 2: Check Query Execution Plan**  
```sql
EXPLAIN ANALYZE SELECT * FROM orders WHERE customer_id = 5;
```
âœ” **Expect `Index Scan` instead of `Seq Scan`!**  

---

## **3ï¸âƒ£ Index-Only Scans (Fastest Query Execution)**  
âœ” **If all columns in a query are covered by an index, PostgreSQL skips fetching rows from disk!**  

âœ… **Create an Index with Covered Columns**  
```sql
CREATE INDEX idx_orders_customer_amount ON orders(customer_id, amount);
```

âœ… **Run a Query That Uses the Index-Only Scan**  
```sql
EXPLAIN ANALYZE SELECT customer_id, amount FROM orders WHERE customer_id = 5;
```
âœ” **Query runs extremely fast using only the index!**  

---

## **4ï¸âƒ£ Bitmap Index Scans (Optimizing Large Result Sets)**  
âœ” **Used when querying large amounts of data where an index alone is inefficient.**  
âœ” **PostgreSQL first fetches matching row locations from an index, then retrieves data in bulk.**  

âœ… **Example Query That Uses a Bitmap Index Scan**  
```sql
EXPLAIN ANALYZE SELECT * FROM orders WHERE amount > 1000;
```
âœ” **If many rows match, PostgreSQL will switch from `Index Scan` to `Bitmap Index Scan` for efficiency.**  

---

## **5ï¸âƒ£ Optimizing Joins (Nested Loop vs. Hash Join)**
âœ” **Joins can slow down queries if not optimized.**  
âœ” PostgreSQL chooses **Nested Loop, Hash Join, or Merge Join** based on table sizes.  

âœ… **Check Query Plan for Join Performance**  
```sql
EXPLAIN ANALYZE 
SELECT users.name, orders.amount 
FROM users 
JOIN orders ON users.id = orders.user_id;
```
âœ” **Expected Optimizations:**  
- **Use `Hash Join` for large datasets.**  
- **Use `Nested Loop Join` for small datasets.**  
- **Ensure indexes exist on `JOIN` keys.**  

âœ… **Optimizing Joins with Indexes**  
```sql
CREATE INDEX idx_orders_user_id ON orders(user_id);
```
âœ” **Speeds up queries involving `JOIN` on `orders.user_id`!**  

---

## **6ï¸âƒ£ Parallel Query Execution (Faster Query Processing)**
âœ” **PostgreSQL can execute queries using multiple CPU cores.**  
âœ” **Enabled by default for queries that process large data.**  

âœ… **Check Parallel Query Execution Settings**  
```sql
SHOW max_parallel_workers_per_gather;
```

âœ… **Increase Parallel Query Execution for Faster Performance**  
```sql
SET max_parallel_workers_per_gather = 4;
```
âœ” **Best for `GROUP BY`, `ORDER BY`, and `JOIN` operations.**  

---

## **7ï¸âƒ£ Optimizer Hints & Cost-Based Optimization**
âœ” PostgreSQL **automatically chooses the best query plan**, but we can influence it using cost-based optimization.  

âœ… **Reduce Sequential Scans by Increasing Random Page Cost**  
```sql
SET random_page_cost = 1.1;
```
âœ” **Encourages PostgreSQL to use indexes instead of sequential scans.**  

âœ… **Force Parallel Execution on a Query**  
```sql
SET parallel_tuple_cost = 0.1;
SET parallel_setup_cost = 0.1;
```
âœ” **Encourages PostgreSQL to use parallel queries!**  

---

## **ğŸ“ Quiz - Query Optimization in PostgreSQL**
1ï¸âƒ£ What does `EXPLAIN ANALYZE` do?  
2ï¸âƒ£ How can you prevent a **Sequential Scan** (`Seq Scan`) in PostgreSQL?  
3ï¸âƒ£ What is an **Index-Only Scan**, and how is it different from an **Index Scan**?  
4ï¸âƒ£ When does PostgreSQL use a **Bitmap Index Scan**?  
5ï¸âƒ£ How can you enable **parallel query execution**?  

Here are the correct answers:  

1ï¸âƒ£ **What does `EXPLAIN ANALYZE` do?**  
âœ” `EXPLAIN ANALYZE` runs a query and **shows the execution plan**, including:  
- **How PostgreSQL executes the query** (Index Scan, Seq Scan, etc.).  
- **Estimated vs. actual execution time**.  
- **Performance bottlenecks** (e.g., slow joins, large sequential scans).  

âœ… **Example:**  
```sql
EXPLAIN ANALYZE SELECT * FROM orders WHERE customer_id = 5;
```
ğŸš€ **Use this to debug slow queries!**  

---

2ï¸âƒ£ **How can you prevent a Sequential Scan (`Seq Scan`) in PostgreSQL?**  
âœ” **Use an index on the column being filtered in `WHERE`**.  

âœ… **Create an Index:**  
```sql
CREATE INDEX idx_orders_customer ON orders(customer_id);
```

âœ… **Run Query & Check Execution Plan:**  
```sql
EXPLAIN ANALYZE SELECT * FROM orders WHERE customer_id = 5;
```
âœ” Expected result: **Index Scan instead of Seq Scan!**  

---

3ï¸âƒ£ **What is an Index-Only Scan, and how is it different from an Index Scan?**  
âœ” **Index-Only Scan**: PostgreSQL retrieves **all required data directly from the index** (faster).  
âœ” **Index Scan**: PostgreSQL uses the index to find rows but **still needs to fetch data from disk**.  

âœ… **Example of Index-Only Scan:**  
```sql
CREATE INDEX idx_orders_customer_amount ON orders(customer_id, amount);
```
```sql
EXPLAIN ANALYZE SELECT customer_id, amount FROM orders WHERE customer_id = 5;
```
ğŸš€ **Since both columns exist in the index, PostgreSQL skips disk access!**  

---

4ï¸âƒ£ **When does PostgreSQL use a Bitmap Index Scan?**  
âœ” **Used when querying a large number of rows where a regular index scan is inefficient**.  
âœ” PostgreSQL first **fetches row locations from an index**, then **retrieves data in bulk**.  

âœ… **Example Query That Triggers Bitmap Index Scan:**  
```sql
EXPLAIN ANALYZE SELECT * FROM orders WHERE amount > 1000;
```
âœ” **If many rows match, PostgreSQL switches from Index Scan to Bitmap Index Scan for efficiency.**  

---

5ï¸âƒ£ **How can you enable parallel query execution?**  
âœ” PostgreSQL automatically enables parallel execution for large queries, but we can **increase parallelism** manually.  

âœ… **Check Current Parallel Execution Setting:**  
```sql
SHOW max_parallel_workers_per_gather;
```

âœ… **Increase Parallel Query Execution:**  
```sql
SET max_parallel_workers_per_gather = 4;
```
ğŸš€ **Now, PostgreSQL will distribute query processing across multiple CPU cores!**  

ğŸ”¥ **Score: 5/5 if you got all correct!** ğŸ¯  

---

### **Next Topic: Logical Decoding & Change Data Capture (CDC)** ğŸš€  
Weâ€™ll cover **Streaming database changes using logical decoding, using `pgoutput` and `wal2json`, and real-time event-driven architectures with PostgreSQL**.