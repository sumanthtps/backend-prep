---
sidebar_position: 8
---
# Views & Materialized Views
Views and materialized views allow you to **simplify complex queries** and **store query results for performance improvements**.  

---

## **1Ô∏è‚É£ What is a View?**  
A **view** is a **virtual table** based on a `SELECT` query. It does not store data but dynamically fetches results from the underlying tables.  

‚úÖ **Example:**  
```sql
CREATE VIEW active_users AS 
SELECT id, name, email 
FROM users 
WHERE is_active = true;
```
Now, you can query it like a table:  
```sql
SELECT * FROM active_users;
```
üöÄ **Benefits of Views:**  
‚úî Simplifies complex queries.  
‚úî Provides security by restricting access to underlying tables.  
‚úî Ensures **data consistency** (always fetches fresh data).  

**‚ö†Ô∏è Limitation:** Every time you query a view, **PostgreSQL recalculates the result** from the base tables, which may slow down performance for large datasets.  

---

## **2Ô∏è‚É£ What is a Materialized View?**  
A **materialized view** is a **physical table** that stores the query result. It does **not refresh automatically** and requires manual updates.  

‚úÖ **Example:**  
```sql
CREATE MATERIALIZED VIEW sales_summary AS 
SELECT user_id, SUM(amount) AS total_sales 
FROM orders 
GROUP BY user_id;
```
üöÄ **Now, querying this view is much faster:**  
```sql
SELECT * FROM sales_summary;
```

‚úÖ **Refreshing a Materialized View:**  
Since it doesn‚Äôt auto-update, use:  
```sql
REFRESH MATERIALIZED VIEW sales_summary;
```

---

## **3Ô∏è‚É£ Views vs. Materialized Views**
| Feature              | View | Materialized View |
|----------------------|------|------------------|
| **Storage**          | No (virtual) | Yes (physical) |
| **Query Speed**      | Slower (recomputed each time) | Faster (stored result) |
| **Updates Automatically?** | ‚úÖ Yes | ‚ùå No (must be refreshed) |
| **Best For**         | Dynamic queries | Performance optimization |

---

## **4Ô∏è‚É£ Indexed Materialized Views (For Even Faster Queries)**
Since materialized views store results, you can **add indexes** for even better performance.  

‚úÖ **Example:**  
```sql
CREATE INDEX idx_sales_summary ON sales_summary(user_id);
```
üöÄ **This speeds up queries like:**  
```sql
SELECT * FROM sales_summary WHERE user_id = 5;
```

---

## **5Ô∏è‚É£ Updatable Views (Modifying Data Through Views)**
By default, views **cannot be updated**. However, you can create **INSTEAD OF triggers** to allow updates.  

‚úÖ **Example (Updatable View with Trigger):**  
```sql
CREATE VIEW user_contacts AS 
SELECT id, name, email FROM users;
```
To allow updates:  
```sql
CREATE RULE update_user_contacts AS 
ON UPDATE TO user_contacts 
DO INSTEAD  
UPDATE users SET name = NEW.name, email = NEW.email WHERE id = NEW.id;
```
üöÄ Now, updating the view works:  
```sql
UPDATE user_contacts SET email = 'new@email.com' WHERE id = 1;
```

---

## **üìù Quiz - Views & Materialized Views**
1Ô∏è‚É£ What is the key difference between a view and a materialized view?  
2Ô∏è‚É£ When should you use a materialized view instead of a normal view?  
3Ô∏è‚É£ How do you manually update a materialized view?  
4Ô∏è‚É£ Can you index a materialized view? If yes, how?  
5Ô∏è‚É£ How can you make a view updatable?  

Drop your answers, and we‚Äôll move to the next advanced topic! üöÄ