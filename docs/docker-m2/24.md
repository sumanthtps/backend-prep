---

title: Starting Your App with CMD
sidebar_position: 51
---------------------

## Overview

After understanding how `ENTRYPOINT` works, it‚Äôs time to explore its sibling: `CMD`.

The `CMD` instruction **provides default arguments or a default command** to run when the container starts. However, its behavior **changes significantly** depending on whether an `ENTRYPOINT` is defined, and whether `CMD` or `ENTRYPOINT` are in **shell** or **exec** form.

Let‚Äôs break this down with examples and key differences.

---

## üîë Key Differences: ENTRYPOINT vs CMD

| Feature                  | ENTRYPOINT                     | CMD                                                              |
| ------------------------ | ------------------------------ | ---------------------------------------------------------------- |
| Primary Role             | Defines **what** to run        | Defines **default arguments** (or what to run, if no ENTRYPOINT) |
| Can be overridden        | No (except via `--entrypoint`) | Yes (via arguments passed to `docker run`)                       |
| Supports Shell/Exec Form | Yes                            | Yes                                                              |
| Works Best With          | `CMD` for flexible arguments   | `ENTRYPOINT` for the actual command                              |

---

## ‚úÖ When ENTRYPOINT and CMD Work Together (Recommended)

### Dockerfile (Exec form)

```dockerfile
ENTRYPOINT ["/app/app.sh"]
CMD ["--debug"]
```

- Running with `docker run my-image` runs:

  ```bash
  /app/app.sh --debug
  ```

- Running with `docker run my-image --config test.yaml` overrides CMD:

  ```bash
  /app/app.sh --config test.yaml
  ```

‚úîÔ∏è This gives a clean and flexible behavior:

- `ENTRYPOINT` is fixed (runs the app),
- `CMD` is flexible (default args, overridden easily).

---

## üß† All Four Combinations (Exec Form)

### 1. Only CMD (No ENTRYPOINT)

```dockerfile
CMD ["/app/app.sh", "--debug"]
```

- Runs the command directly.
- App is the top-level process (PID 1).
- Accepts arguments passed via `docker run`.

üî∫ Not ideal ‚Äî better to use ENTRYPOINT to separate logic from args.

---

### 2. ENTRYPOINT and CMD Together (‚úÖ Best Practice)

```dockerfile
ENTRYPOINT ["/app/app.sh"]
CMD ["--debug"]
```

- CMD becomes **default arguments to ENTRYPOINT**.
- Users can override with their own args.

‚úÖ Recommended for flexibility.

---

### 3. ENTRYPOINT Only (No CMD)

```dockerfile
ENTRYPOINT ["/app/app.sh"]
```

- No default arguments.
- Users **must** supply args via `docker run` or the app runs with none.

---

### 4. Neither ENTRYPOINT nor CMD

```dockerfile
# No ENTRYPOINT or CMD
```

- Inherits CMD/ENTRYPOINT from **base image**.
- If `FROM scratch`, falls back to:

  - Linux: `/bin/sh -c`
  - Windows: `cmd /S /C`

üî¥ Often confusing, not recommended.

---

## ‚ö†Ô∏è Behavior of Shell Form

When using shell form:

```dockerfile
CMD /app/app.sh --debug
```

The command runs as:

```bash
/bin/sh -c "/app/app.sh --debug"
```

Problems:

- The app is **not PID 1**.
- Arguments cannot be overridden cleanly.
- Signals like `SIGINT` (Ctrl+C) are intercepted by the shell, **not passed to
  your app**.

Thus:

> ‚ùå Avoid shell form for `CMD` and `ENTRYPOINT` unless you have a compelling
> reason.

---

## üß™ Example: CMD Without ENTRYPOINT

```dockerfile
CMD ["/app/app.sh"]
```

Then:

```bash
docker build -t my-image .
docker run --rm my-image
```

‚úÖ Works fine.

But:

```bash
docker run --rm my-image --custom-arg
```

üî¥ Fails!

Docker tries to execute `--custom-arg` using the default shell (`/bin/sh -c`) ‚Äî
and since `--custom-arg` is **not** a valid program, it crashes.

**Why?**

- Without ENTRYPOINT, Docker assumes `CMD` is the entire command.
- If CMD is overridden by args, then your args must include the full program.

---

## ‚úÖ Fix: Use ENTRYPOINT + CMD

```dockerfile
ENTRYPOINT ["/app/app.sh"]
CMD ["--default-arg"]
```

Then:

```bash
docker run --rm my-image
# ‚Üí /app/app.sh --default-arg

docker run --rm my-image --override-arg
# ‚Üí /app/app.sh --override-arg
```

---

## ‚ùå What If You Put Args Inside ENTRYPOINT?

```dockerfile
ENTRYPOINT ["/app/app.sh", "--default-arg"]
```

Then:

```bash
docker run --rm my-image --override-arg
```

‚û°Ô∏è Runs:

```bash
/app/app.sh --default-arg --override-arg
```

üî¥ Problem: You **can‚Äôt override** `--default-arg` anymore.

‚úÖ Fix: Move `--default-arg` into CMD.

---

## üìå Summary

| Scenario                      | Behavior                                                          |
| ----------------------------- | ----------------------------------------------------------------- |
| CMD only                      | Good only if no ENTRYPOINT needed. All args must be full command. |
| ENTRYPOINT only               | Works, but no default args.                                       |
| ENTRYPOINT + CMD (exec form)  | ‚úÖ Best practice. CMD becomes default args.                       |
| ENTRYPOINT + CMD (shell form) | üî¥ CMD args not passed to ENTRYPOINT. Avoid.                      |
| CMD in shell form             | ‚ùå Hard to override, signal issues. Avoid.                        |
| CMD as fallback only          | Acceptable for base images, but unclear behavior.                 |

---

## Questions and Answers

### Q1: Can I override CMD when running the container?

Yes.

```bash
docker run my-image --new-arg
```

Overrides the CMD args if you're using `ENTRYPOINT`.

---

### Q2: Can I override ENTRYPOINT?

Yes, using:

```bash
docker run --entrypoint "/bin/bash" my-image
```

Helpful for debugging.

---

### Q3: What happens if both ENTRYPOINT and CMD are shell form?

Arguments won't pass through properly. Avoid this setup.

---

### Q4: Can I hardcode multiple arguments in ENTRYPOINT?

Yes, but:

```dockerfile
ENTRYPOINT ["/app/app.sh", "--arg1", "--arg2"]
```

Doing this **locks in** those args. Users can‚Äôt override.

---

### Q5: How to pass default args but still allow override?

Use:

```dockerfile
ENTRYPOINT ["/app/app.sh"]
CMD ["--default-arg"]
```

---

By understanding how CMD works ‚Äî and especially how it interacts with ENTRYPOINT
‚Äî you gain fine-grained control over how your Docker containers behave at
runtime.
