---

title: Updating the Image in Dockerfile
sidebar_position: 48
---------------------

## Introduction

After creating a basic Docker image using `FROM` and `COPY`, it's common to **update the Dockerfile** to include more application files or configurations. In this section, we build on our previous example by copying all files from our project context into the container and observing how Docker treats those changes internally.

---

## Updated COPY Instruction

To copy all files from the **build context** (the directory where `docker build`
is run) into a specific directory (e.g., `/app`) in the container image, use:

```dockerfile
COPY . /app
```

- `.` refers to all files in the current folder (context).
- `/app` is the target directory inside the container image.

---

## Building the Updated Image

```bash
docker image build .
```

This creates a **new layer** on top of the base image (e.g., Ubuntu),
representing the newly added files. Docker’s layered architecture ensures:

- Only changes are saved as new layers.
- Unchanged base image layers (like Ubuntu) are reused.

---

## Understanding the Image IDs

After building:

```bash
docker image ls
```

You may see:

- **No repository/tag name** — means the image was created without a name.
- A unique **image ID**, e.g., `d2a8...`

If your image only had a `FROM ubuntu` earlier, it would **share the same ID**
as the Ubuntu base image. After adding `COPY`, a new layer is added, so it gets
a new ID.

---

## Running the Updated Image

To test if the contents were copied:

```bash
docker run --rm d2a8 ls /app
```

- `--rm`: removes the container after it exits
- `d2a8`: image ID (first few characters are sufficient)
- `ls /app`: command executed inside the container

✅ You should see your project files listed inside `/app`.

---

## Why did `docker run d2a8` do nothing?

You might notice that running:

```bash
docker run --rm d2a8
```

...seems to do **nothing**.

### Why?

Docker images have a **default command** they execute when you run them. This is
defined using the `CMD` instruction in the Dockerfile.

In this case:

- Your Dockerfile **didn't define a `CMD`**
- But the **base image (Ubuntu)** _does_, and it’s:

  ```dockerfile
  CMD ["/bin/bash"]
  ```

So Docker ran Bash.

But since Bash expects an **interactive terminal** (stdin), and you didn’t
provide any input or a command to execute, Bash exited immediately.

---

## Inspecting the Image

To understand what's configured in your image:

```bash
docker image inspect d2a8
```

Look for the `Config.Cmd` field:

```json
"Cmd": [
  "/bin/bash"
]
```

This tells us:

- The container tries to start with Bash by default.
- No commands = Bash quits = container exits.

---

## Providing a Command to Bash

To make it useful, pass a command after the image ID:

```bash
docker run --rm d2a8 ls /app
```

You’ll get a list of files inside `/app`.

You can also try:

```bash
docker run -it d2a8
```

- `-i`: interactive (keep stdin open)
- `-t`: allocate a pseudo-TTY (so Bash works interactively)

This drops you into a working shell inside the container.

---

## Why Did Bash Get Installed?

We never explicitly added `bash` in our Dockerfile — but it still exists in the
container. Why?

### Answer:

Because **Ubuntu base image** contains Bash and defines:

```dockerfile
CMD ["/bin/bash"]
```

You **inherit this** when your Dockerfile doesn't override it.

---

## Summary

| Command                        | Purpose                                                 |
| ------------------------------ | ------------------------------------------------------- |
| `COPY . /app`                  | Copies all context files into `/app` in the container   |
| `docker image build .`         | Builds the Docker image from current folder             |
| `docker run --rm <image-id>`   | Runs the image (defaults to base image CMD like `bash`) |
| `docker run --rm <id> ls /app` | Runs `ls /app` in the container                         |
| `docker image inspect <id>`    | View config like default CMD and entrypoint             |

---

## Questions & Answers

### Q1: Why did nothing happen when running `docker run <image-id>`?

✅ **Because the container used Bash as the default CMD**, but no command or
input was provided, so Bash exited immediately.

---

### Q2: Why is `/bin/bash` in the image if we didn’t add it?

✅ **Because the base image (`ubuntu`) includes it**, and defines it as the
default command via `CMD`.

---

### Q3: What’s the effect of `COPY . /app`?

✅ It copies **everything from the context** (current directory) into `/app`
inside the container image.

---

### Q4: How does Docker know what command to run when starting a container?

✅ It uses the last defined `CMD` instruction (either in your Dockerfile or
inherited from the base image).

---

### Q5: What happens if you define your own `CMD`?

It **overrides the base image's CMD**.

```dockerfile
CMD ["node", "app.js"]
```

Now your container would run `node app.js` instead of `/bin/bash`.

---

Next step: You’ll learn how to define your **own CMD instruction** to control
what your image does on startup.
