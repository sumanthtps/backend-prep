---

title: The Anatomy of a Dockerfile
sidebar_position: 44
---------------------

## Introduction

In previous chapters, we explored how Docker images are built from multiple **layers**â€”each stored as a compressed `tar` archiveâ€”and how these layers are mounted using **OverlayFS**. While it's possible to manually create these layers using scripts or tools like `tar`, itâ€™s cumbersome, error-prone, and not scalable.

To solve this, Docker introduced a **domain-specific language** called the **Dockerfile**â€”a declarative way to automate image creation using simple, human-readable instructions.

---

## Why Not Use Scripts or Configuration Tools?

Letâ€™s consider two alternative (but flawed) approaches:

### 1. **Shell Scripts**

- You could theoretically use bash scripts with `tar` to package and compress
  each layer.
- **Problems**:

  - Complex: You must handle every file operation and command manually.
  - Error-prone: Youâ€™d have to anticipate all possible user actions.
  - Hard to maintain and debug.

### 2. **Configuration Management Tools (e.g., Ansible, Chef)**

- You might use tools designed for server setup to build your images.
- **Problems**:

  - Adds overhead: Requires the tools to be installed on every machine.
  - Complex configuration.
  - Low portability.

**Conclusion**: These methods are too heavy, too complex, or too manual.

---

## Enter: Dockerfile

> A **Dockerfile** is a plain text file containing all the commands a user could
> call on the command line to assemble a Docker image.

- Itâ€™s **declarative**, **lightweight**, and **version-controllable**.
- Every Dockerfile starts with a base image and adds layers on top using
  well-defined **instructions**.

---

## Dockerfile Structure

Each line in a Dockerfile is a separate instruction.

```Dockerfile
# This is a comment
FROM ubuntu:20.04
COPY ./Include /app/data
RUN chmod +x /app/data/install.sh
CMD ["/app/data/install.sh"]
```

### Basic Syntax

- The first word is the **instruction** (e.g., `FROM`, `COPY`, `RUN`).
- Everything after it is passed as **arguments**.
- Instructions are processed **top to bottom**.

### Intermediate Containers

Most instructions (except metadata instructions like `LABEL` or `EXPOSE`) run in
**intermediate containers**:

1. Docker creates a container from the current image.
2. Executes the command.
3. Commits the result as a new layer.
4. Repeats for the next instruction.

![Dockerfile to Layer Mapping](https://docs.docker.com/images/dockerfile-layers.png)

> ðŸ“Œ _Not all instructions generate layers_ For example, `ENV`, `LABEL`, and
> `EXPOSE` modify metadata.

---

## Essential Dockerfile Instructions (Preview)

We will explore each of these in detail in the next sections, but here is a
quick overview:

| Instruction  | Purpose                                                    |
| ------------ | ---------------------------------------------------------- |
| `FROM`       | Base image to start from                                   |
| `COPY`       | Copy files from host to container                          |
| `ADD`        | Like `COPY`, but can also extract archives and access URLs |
| `RUN`        | Execute a command and add the result to the image          |
| `CMD`        | Default command to run when container starts               |
| `ENTRYPOINT` | Configures a container to run as an executable             |
| `ENV`        | Set environment variables                                  |
| `WORKDIR`    | Set the working directory                                  |
| `EXPOSE`     | Document ports the container listens on                    |
| `LABEL`      | Add metadata                                               |
| `USER`       | Set user that runs container processes                     |

---

## Comments in Dockerfile

- Begin with `#`
- Not interpreted by Docker
- Useful for documentation and clarity

```Dockerfile
# This line adds the script into the image
COPY app.sh /usr/local/bin/
```

---

## Dockerfile Build Process Summary

1. Docker starts reading the Dockerfile line by line.
2. For each command:

   - Executes it in an **intermediate container**.
   - Saves the output as a new **layer**.

3. Final image is created from all layers.

> **Analogy**: Think of Dockerfiles like a recipe. Each step adds an ingredient
> or changes the state, and the final dish is your Docker image.

---

## Exercise Setup Mentioned

The course provides:

- A **shell script**: `app.sh`
- A folder: `Include/` These will be used to demonstrate file copying and
  permissions.

You **donâ€™t need to know shell scripting** to follow alongâ€”any shell nuances
will be explained as you build.

---

## Key Takeaways

- Dockerfiles automate the image creation process in a portable, readable way.
- They eliminate the need for manual scripting or external tools like Ansible.
- The build process involves **intermediate containers** and **layering**.
- Each Dockerfile line corresponds to a new instruction and often a new layer.
- Comments improve readability and maintainability.

---

## Questions & Answers

**Q1: Why not use scripts to create Docker layers?** **A:** Too complex and
error-prone. Managing every possible command in shell is impractical.

**Q2: Whatâ€™s the problem with Ansible or Chef?** **A:** Adds dependency overhead
and reduces portability across machines.

**Q3: Why is Dockerfile better?** **A:** Itâ€™s declarative, portable,
versionable, and integrated into Dockerâ€™s tooling.

**Q4: What is an intermediate container?** **A:** A temporary container used to
execute one Dockerfile instruction and produce a layer.

**Q5: Do all Dockerfile instructions create layers?** **A:** No. Metadata
instructions like `LABEL`, `EXPOSE`, and `ENV` may not.

---
