---
id: docker-best-practices
title: Docker Best Practices
sidebar_position: 86
---

## Summary

This section emphasizes three critical Docker best practices for real-world use:

1. **Use verified or trusted images**
2. **Avoid tagging images as `latest`**
3. **Run containers as non-root users**

Each practice is rooted in **security**, **stability**, and **maintainability**,
all essential when deploying applications at scale or in production
environments.

---

## Key Concepts

### 1. Use Verified or Trusted Images

#### â— Problem:

Unverified images on Docker Hub may contain **malware**, such as **crypto
miners**, credential stealers, or data exfiltration tools.

#### ðŸ” Real-world case:

- **Image**: `alpine2`
- **Issue**: Ran Alpine Linux but installed a crypto miner
- **Impact**: Large **cloud costs** due to outbound traffic

#### âœ… Solution:

- Use **official/verified images**: Look for the âœ… **blue check mark** or
  **"Docker Official Image"** label in Docker Hub. Example (Ubuntu image):
  ![Verified Docker Image - Ubuntu](https://docs.docker.com/images/docker-official-image.png)

- Use **image scanning tools**:

  - [Clair](https://github.com/quay/clair)
  - [Trivy](https://github.com/aquasecurity/trivy)
  - [Dagda](https://github.com/eliasgranderubio/dagda)

These tools scan layers for:

- Known CVEs
- Malicious files
- Misconfigurations

> **INFO**: Verified images may not cover all use cases. Use scanners for both
> verified and custom images.

---

### 2. Avoid Using `latest` Tag

#### â— Problem:

The `latest` tag can lead to:

- **Unpredictable deployments** (version not pinned)
- **Undetectable breaking changes**
- **Overwritten tags in registries**

#### âœ… Solution:

- Use **explicit version tags** (`myapp:1.0.2`, `nginx:1.25.3`)
- Even for local builds, always tag properly:

```bash
docker build -t myapp:1.0.2 .
```

> ðŸ’¡ Treat container versions like application releases â€” they must be
> deterministic.

---

### 3. Run Containers as Non-Root Users

#### â— Problem:

Containers run as `root` by default:

- **Privileged access inside the container**
- Potential **escalation to host system** (especially if privileged mode or host
  mounts are used)

#### âœ… Solution:

##### For containers built from your own images:

Use the `USER` instruction in Dockerfile:

```Dockerfile
FROM node:20
RUN useradd -m myuser
USER myuser
```

##### For containers using public images:

Use `--user` flag when running:

```bash
docker run --user 1001:1001 myimage
```

##### ðŸ”’ Bonus: Combine with Linux Capabilities

Reduce the containerâ€™s privileges:

```bash
docker run --cap-drop=ALL --cap-add=NET_BIND_SERVICE myimage
```

> See detailed Linux capabilities:
> ![Linux Capabilities in Docker](https://docs.docker.com/images/capabilities-table.png)
> Source:
> [Docker Docs - Runtime Privilege & Linux Capabilities](https://docs.docker.com/engine/reference/run/#runtime-privilege-and-linux-capabilities)

---

## Missing Improvements

| Topic                | Improvement / Clarification                                                                                |
| -------------------- | ---------------------------------------------------------------------------------------------------------- |
| Image Trust Chains   | Use **Docker Content Trust (DCT)** to sign and verify images (`DOCKER_CONTENT_TRUST=1`)                    |
| Reproducible Builds  | Use deterministic tools (e.g., `apk`, `apt`, `pip`) with pinned versions inside Dockerfile                 |
| Cache Busting        | Structure `Dockerfile` to maximize layer caching                                                           |
| Secrets Management   | Never store secrets in Dockerfile or image layers; use **Docker Secrets** or external tools                |
| SBOM & Compliance    | Integrate **Software Bill of Materials** tools like [Syft](https://github.com/anchore/syft) for compliance |
| Resource Constraints | Use `--memory`, `--cpus`, and cgroups to limit container resource abuse                                    |

---

## Questions & Answers

**Q1. Why is using `latest` a bad idea for production?** Because `latest` is
mutable and non-deterministic. It might fetch a different image version during
future pulls, causing unexpected behavior.

**Q2. Is it okay to use non-verified images?** Yes, but only if you're confident
in the source and use image scanners like **Trivy** or **Clair** to check for
malware or vulnerabilities.

**Q3. What if a container breaks when run as non-root?** Some applications
assume root access. You may:

- Modify the image to create/apply permissions to non-root users
- Use `chown`, `chmod`, or Dockerfile `RUN` commands to adjust file access

---

## Open Source Tools Mentioned

| Tool                 | Purpose                      | Link                                                                                             |
| -------------------- | ---------------------------- | ------------------------------------------------------------------------------------------------ |
| Trivy                | Vulnerability/image scanner  | [https://github.com/aquasecurity/trivy](https://github.com/aquasecurity/trivy)                   |
| Clair                | CVE image scanner            | [https://github.com/quay/clair](https://github.com/quay/clair)                                   |
| Dagda                | Malware + CVE scanner        | [https://github.com/eliasgranderubio/dagda](https://github.com/eliasgranderubio/dagda)           |
| Syft                 | SBOM generation              | [https://github.com/anchore/syft](https://github.com/anchore/syft)                               |
| Docker Content Trust | Image signature verification | [https://docs.docker.com/engine/security/trust/](https://docs.docker.com/engine/security/trust/) |

---

Would you like the **MCQs and explanations** for this section next?
