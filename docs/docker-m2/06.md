---

title: Docker Knowledge Check – Questions and Answers
sidebar_position: 32
---------------------

## Question 1 of 15

**You want to experiment with the `crun` container runtime. Which of these files would you need to edit to make this change?**

* `/var/run/docker.sock`
* `/var/lib/docker/daemon.json`
* **✅ /etc/docker/daemon.json**
* `/var/run/docker.json`

**Explanation:**
Docker’s `daemon.json` under `/etc/docker/` controls daemon-level settings such as the default runtime. You can specify `"default-runtime": "crun"` here.

---

## Question 2 of 15

**Which of these paths contains container metadata?**

- **✅ /var/lib/docker**
- `/var/run/docker`
- `/var/lib/docker/overlay`
- `/etc/docker`

**Explanation:** `/var/lib/docker` is Docker’s main data directory containing
images, container metadata, and state.

---

## Question 3 of 15

**Which of these paths contains container volumes?**

- `/etc/docker`
- `/var/run/docker`
- `/var/lib/docker`
- **✅ /var/lib/docker/overlay**

**Explanation:** The Overlay2 directory stores union file system layers and
container volumes.

---

## Question 4 of 15

**Which of these features are not provided by container engines directly?**

- a command-line client
- **✅ creating and stopping containers**
- a language for creating container images
- an API for managing containers

**Explanation:** Creating/stopping containers is handled by the **container
runtime** (e.g., `runc`, `crun`). Engines provide the higher-level interface.

---

## Question 5 of 15

**Which of these container runtimes is the default for Podman?**

- kata
- runc
- containerd
- **✅ crun**

**Explanation:** Podman uses `crun` as its default runtime due to its
performance and rootless support.

---

## Question 6 of 15

**Which of these container runtimes is the default for the Docker Engine?**

- **✅ containerd**
- kata
- crun
- runc

**Explanation:** Docker Engine uses `containerd` as the primary runtime manager.
`containerd` then calls `runc`.

---

## Question 7 of 15

**Which of these answers most accurately describes the difference between
OCI-compliant runtimes and CRI-compliant runtimes?**

- **✅ OCI-compliant runtimes produce containers that adhere to the OCI runtime
  specification. CRI-compliant runtimes produce OCI-compliant containers that
  adhere to the Container Runtime Interface.**
- OCI-compliant runtimes produce containers that adhere to the CRI runtime
  specification. CRI-compliant runtimes produce OCI-compliant containers that
  adhere to the Container Runtime Interface.
- OCI-compliant runtimes produce containers that can run on virtual machines.
  CRI-compliant runtimes produce containers that cannot run on virtual machines.

**Explanation:** OCI defines the runtime spec; CRI is Kubernetes’ standard for
talking to runtimes.

---

## Question 8 of 15

**Which of these runtimes is not OCI-compliant?**

- crun
- **✅ AWS Firecracker**
- runc
- gVisor

**Explanation:** Firecracker is a microVM technology and does not implement the
OCI Runtime Spec.

---

## Question 9 of 15

**Which statement most accurately describes the OCI runtime spec?**

- The OCI runtime specification provides a standard for running containers on
  virtual machines.
- The OCI runtime specification provides a standard for creating and managing
  containers and describes how these activities should be done.
- The OCI runtime specification provides a standard for running containers
  against unikernels for increased isolation.
- **✅ The OCI runtime specification provides a standard for creating and
  managing containers, but does not dictate how to perform these activities.**

**Explanation:** The spec defines _what_ must be supported, not _how_ to
implement it.

---

## Question 10 of 15

**Which of these activities are container runtimes not responsible for?**

- attaching control groups to namespaces
- **✅ pulling container images**
- setting namespace capabilities
- creating namespaces

**Explanation:** Image pulling is done by the container engine (`dockerd`,
`podman`). Runtimes handle namespace and cgroup setup.

---

## Question 11 of 15

**\_\_\_\_\_ define what resources containers can access. \_\_\_\_\_ define how
much of those resources containers can consume.**

- Namespaces, mounts
- Control groups, namespaces
- **✅ Namespaces, control groups**
- Mounts, control groups

**Explanation:** Namespaces = resource isolation. Cgroups = resource limits and
accounting.

---

## Question 12 of 15

**Which of these Linux system calls creates a new namespace for a process?**

- **✅ unshare**
- createns
- newns
- share

**Explanation:** `unshare()` is the syscall that detaches a process from current
namespaces and can create new ones.

---

## Question 13 of 15

**Virtual machines emulate \_\_\_\_\_. Containers emulate \_\_\_\_\_.**

- images, hardware
- **✅ hardware, operating systems**
- hardware, images
- operating systems, hardware

**Explanation:** VMs emulate hardware via a hypervisor. Containers share the OS
kernel and emulate isolated OS environments.

---

## Question 14 of 15

**Which of these two Linux kernel features are containers comprised of?**

- Symlinks and namespaces
- Control groups and FUSE-mounted directories
- Symlinks and FUSE-mounted directories
- **✅ Control groups and namespaces**

**Explanation:** Namespaces provide isolation, cgroups provide resource control.

---

## Question 15 of 15

**Which of these problems does Docker aim to solve?**

- Use configuration-as-code to bring groups of machines to a desired state.
- Use configuration-as-code to create and configure pre-made virtual machines.
- **✅ Ensure that applications run and behave the same on any machine,
  anywhere.**
- Reduce application build times by detecting and removing duplicated and dead
  code.

**Explanation:** Docker packages applications and dependencies into images,
ensuring consistent behavior across environments.
