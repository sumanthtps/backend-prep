---
id: creating-container-to-run-containers
title: Creating the Container to Run Containers
sidebar_position: 65
---

## Summary

This section explains how to **create a container that can launch and manage
other containers** — a practice known as **Docker-outside-of-Docker (DooD)**. It
introduces two approaches: installing Docker _inside_ the container (DinD) vs.
accessing the host's Docker **via socket binding** (preferred for simplicity and
compatibility).

---

## Key Concepts

### 🧱 Two Approaches to Run Containers from Containers

| Approach                            | Description                                                            | Pros                                               | Cons                                                    |
| ----------------------------------- | ---------------------------------------------------------------------- | -------------------------------------------------- | ------------------------------------------------------- |
| **DinD (Docker-in-Docker)**         | Install full Docker engine (`dockerd`) inside the container            | True isolation                                     | Complex setup, file system and cgroup issues            |
| **DooD (Docker-outside-of-Docker)** | Mount host Docker socket (`/var/run/docker.sock`) inside the container | Easy, lightweight, real-time access to host engine | Security risk: grants full access to host Docker daemon |

---

### ⚠️ Why DinD is Problematic

#### 1. **Cgroup v2 Issues**

- Docker depends on **cgroup v2** to allocate resources.
- Managing cgroups _within_ a container is not straightforward.

#### 2. **OverlayFS Limitation**

- Docker containers use **OverlayFS** (a union file system).
- OverlayFS **cannot nest** within another OverlayFS, which breaks DinD.
- Workarounds exist (e.g., VFS storage driver, sysbox), but they are
  **non-trivial**.

#### 3. **Network Accessibility**

- Nested containers in DinD are **not visible** from the host, complicating
  debugging and networking.

---

## 🔁 Preferred Method: Socket Binding (DooD)

### 🔗 Mount Docker UNIX Socket

```bash
docker run --rm \
  -v /var/run/docker.sock:/var/run/docker.sock \
  --entrypoint bash -it my-image
```
````

> This gives the container **direct access to the host Docker engine**, using
> the host daemon to launch/manage containers.

---

### 📡 Test with Curl

```bash
curl --unix-socket /var/run/docker.sock http://anything/containers/json
```

- The `--unix-socket` flag lets `curl` communicate directly with the Docker
  daemon.
- You receive the same JSON as running `docker ps` or `docker inspect`.

---

### 📘 Understanding the Docker API

The Docker engine exposes a **REST API**.

- Common endpoints:

  - `GET /containers/json` → list containers
  - `POST /containers/create` → create container
  - `POST /containers/start` → start container

📚 Explore the full API docs:
[Docker Engine API v1.43](https://docs.docker.com/engine/api/v1.43/)

---

## 🔧 Missing Concept: What is Bind Mounting?

- A **bind mount** links a **host path** to a **container path**.
- In this case:

  ```bash
  -v /var/run/docker.sock:/var/run/docker.sock
  ```

  gives the container access to the **host’s Docker daemon socket**.

---

### 🧰 Tools: Sysbox

If you want _true_ DinD without all the cgroup/overlay pain, consider:

- **[Sysbox](https://github.com/nestybox/sysbox)** by Nestybox

  - OCI-compatible container runtime.
  - Allows secure Docker-in-Docker **without `--privileged`**.
  - Handles cgroup, nesting, and proc/sysfs emulation automatically.

📸 Image:
![Sysbox Diagram](https://github.com/nestybox/sysbox/blob/master/docs/media/sysbox-arch.png?raw=true)
_Source: [Nestybox GitHub](https://github.com/nestybox/sysbox)_

---

## MCQ-Style Questions

### 📌 Q1: What is a major limitation of installing Docker inside a container?

A. Containers cannot run inside containers B. OverlayFS cannot overlay OverlayFS
C. You cannot use bind mounts D. Docker is not supported inside Linux containers

**✅ Correct Answer:** B

**Explanation:**

- B is correct — OverlayFS cannot nest.
- A is false — containers _can_ be created, but not easily nested.
- C is false — bind mounts work in containers.
- D is false — Docker works fine in Linux containers, if configured properly.

---

### 📌 Q2: What does the following bind mount do?

```bash
-v /var/run/docker.sock:/var/run/docker.sock
```

A. Shares memory between containers B. Provides the container access to host
disk C. Allows the container to manage the host's Docker daemon D. Exposes
container logs to the host system

**✅ Correct Answer:** C

**Explanation:**

- This gives the container direct access to Docker's UNIX socket on the host.
- With this, the container can **create and manage containers on the host**.

---

## Conclusion

Rather than complicating your setup with true Docker-in-Docker (DinD), it's
often better to **bind-mount Docker’s UNIX socket** into your container — a
common and accepted practice for automation, CI/CD, and internal tooling. When
you need full nesting or security isolation, tools like **Sysbox** can help.

---
