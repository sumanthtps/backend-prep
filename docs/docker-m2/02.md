---
title: Container Runtimes – The Engine Behind Your Containers
sidebar_position: 28
---

## Introduction

In the last section, we learned that **Linux namespaces** and **control groups
(cgroups)** form the core isolation mechanisms behind containers. But how are
these low-level features used to create an actual container?

To understand that, we must first understand what a **container runtime** is.

---

## The Life of a Container (Manual Process)

Before Docker, some teams **manually created containers** using native Linux
tools. Here’s what that process looked like:

### Step 1: Mount the File System

Create a root directory that mimics the Linux file system:

```bash
mkdir -p ~/mycontainer/{bin,lib,etc,usr}
```

Copy all application dependencies into this structure.

> This becomes the **root file system** of your container.

---

### Step 2: Isolate with Namespaces

Use the `unshare` command (a wrapper over the `unshare()` syscall):

```bash
unshare --mount --uts --ipc --net --pid --fork --user /bin/bash
```

- **Mount** namespace → own file system.
- **UTS** namespace → own hostname.
- **PID** namespace → own process tree.
- **Net** namespace → own network stack.
- **User** namespace → mapped UID/GID.

> Creates a virtual "sandbox" for the process.

---

### Step 3: Use `chroot` to Change Root

Prevent file system access to real `/`:

```bash
chroot ~/mycontainer /bin/bash
```

Now your app believes `~/mycontainer` is the root directory.

---

### Step 4: Apply cgroups

To limit resource usage (e.g., CPU, memory):

```bash
# Create a new cgroup
mkdir /sys/fs/cgroup/memory/mycontainer
echo 100000000 > /sys/fs/cgroup/memory/mycontainer/memory.limit_in_bytes
echo $$ > /sys/fs/cgroup/memory/mycontainer/tasks
```

> This restricts your container to 100MB of memory.

---

### Step 5: Capabilities – Syscall Restrictions

Linux provides fine-grained access control via **capabilities**:

```bash
capsh --drop=cap_net_bind_service -- -c "./run-my-app"
```

```
- Drops permission to bind to ports <1024.
- There are 30+ capabilities like `CAP_SYS_ADMIN`, `CAP_NET_RAW`.
```

> Think of capabilities as **partial root permissions**.

---

## Challenge: This Is Too Hard!

Doing all of this manually for each container is:

- **Time-consuming**
- **Error-prone**
- Lacks networking, image packaging, or storage abstraction.

---

## Solution: Container Runtimes

A **container runtime** automates this entire process.

### What It Does:

✅ Set up namespaces ✅ Apply cgroups ✅ Configure capabilities ✅ Create the
container process ✅ Clean it up after exit

Instead of doing all this manually:

```bash
docker run myimage
```

> Everything happens behind the scenes using the container runtime.

---

## Container Runtime vs Container Engine

These two terms are often **confused**. Let’s clarify.

| Feature                        | Container Runtime            | Container Engine            |
| ------------------------------ | ---------------------------- | --------------------------- |
| Creates and manages containers | ✅                           | ✅                          |
| Applies namespaces, cgroups    | ✅                           | ✅ (via runtime)            |
| Provides CLI and API           | ❌                           | ✅                          |
| Pulls images from registries   | ❌                           | ✅                          |
| Builds images                  | ❌                           | ✅                          |
| Handles image caching/layers   | ❌                           | ✅                          |
| Example                        | `runc`, `containerd`, `crun` | `Docker`, `Podman`, `CRI-O` |

### In Summary:

- **Container runtime** = low-level, technical container lifecycle manager.
- **Container engine** = user-facing tool with a full developer experience.

---

## Popular Container Runtimes

### 1. **runc** (Default in Docker)

- Created by Docker, now part of **Open Container Initiative (OCI)**.
- Written in Go.
- Uses `libcontainer` to configure cgroups, namespaces, etc.

### 2. **containerd**

- A daemon that runs containers.
- Used by **Docker** (as of version 1.11+).
- Interfaces with `runc`.
- Can be used independently (e.g., Kubernetes CRI).

### 3. **crun**

- Lightweight runtime written in **C**.
- Faster startup than `runc`.
- Often used by **Podman** and **CRI-O**.

### 4. **gVisor**

- Developed by Google.
- **Sandboxed runtime**: intercepts syscalls and emulates them in user space.
- High isolation; good for multi-tenant platforms.

### 5. **Kata Containers**

- Based on **lightweight VMs**.
- Each container runs inside a minimal VM.
- Combines VM-level isolation with container workflows.

---

## Example: Docker Internals Flow

Here’s what happens when you run:

```bash
docker run nginx
```

Internally:

1. Docker (engine) parses the CLI.
2. It pulls the image `nginx` (if not present).
3. Docker delegates to `containerd`.
4. `containerd` uses `runc` to create a container.
5. `runc` applies:

   - Namespaces
   - Cgroups
   - Capabilities

6. Container starts and runs `nginx`.

---

## Advanced Topics

- Runtime Specification → Defined by **OCI Runtime Spec**.
- User namespaces for rootless containers.
- Custom seccomp profiles.
- Interfacing with Kubernetes via CRI (Container Runtime Interface).

---

## Questions and Answers

### Q1: What is a container runtime?

**A**: A low-level software component that sets up the environment for
containers using Linux kernel features like namespaces and cgroups.

---

### Q2: Is Docker a container runtime?

**A**: No, Docker is a **container engine**. It uses **containerd** and **runc**
internally as the actual runtimes.

---

### Q3: Why do we need container runtimes?

**A**: To abstract the complex Linux syscalls and steps needed to isolate a
process securely and efficiently.

---

### Q4: Can Kubernetes use different runtimes?

**A**: Yes. Kubernetes interfaces with runtimes via the **CRI (Container Runtime
Interface)**. It can use:

- `containerd`
- `CRI-O`
- `dockershim` (deprecated)

---

### Q5: What is the OCI?

**A**: **Open Container Initiative** defines standards for container images and
runtimes. It ensures tools are interoperable.

---

## Conclusion

Container runtimes are the **heart of containerization**. They turn a bunch of
syscalls and kernel features into something you can run with a single command.
While Docker made containers user-friendly, it’s the **runtimes like runc and
containerd** that do the heavy lifting under the hood.

In the next section, we’ll explore how **Docker builds and stores container
images**, and how layering works in detail.

```

Let me know if you’d like a diagrammatic view of `engine → containerd → runc → Linux syscalls` stack, or a deeper explanation on OCI runtime specs or CRI plugin development.
```
