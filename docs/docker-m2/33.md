---

title: MCQ2
sidebar_position: 59
---------------------
### ✅ **Question 1**

**In Linux containers, the \_\_\_\_\_ form provides every word after RUN as an
argument to \_\_\_\_\_. \_\_\_\_\_ form executes the first word after RUN as a
program, with everything else provided to it as arguments.**

**Options:**

- A) exec, /bin/sh -c, shell
- B) shell, /bin/sh -c, exec ✅
- C) shell, cmd /S /C, exec
- D) exec, cmd /S /C, shell

**Correct Answer: B) shell, /bin/sh -c, exec**

**Explanation:**

- **Correct**: In shell form, Docker wraps the command in `/bin/sh -c` for Linux
  containers. In exec form, Docker directly runs the executable as PID 1.
- **A is incorrect**: The shell form uses `/bin/sh -c`, not `exec`.
- **C and D are incorrect**: These mix Windows (`cmd /S /C`) which is not
  relevant to Linux containers.

---

### ✅ **Question 2**

**You are debugging a Dockerfile and encounter:
`/scripts: no such file or directory.` What is the most likely issue?**

**Options:**

- A) ARG commands must come before FROM
- B) The nginx image does not have a /scripts directory in it. Add
  `COPY . /scripts` anywhere in the Dockerfile.
- C) The RUN command must be in exec form instead of shell form.
- D) The nginx image does not have a /scripts directory in it. Add
  `COPY . /scripts` before the RUN command ✅

**Correct Answer: D**

**Explanation:**

- **Correct**: The error is due to `/scripts` not existing in the base image.
  You must copy it before trying to use it in `RUN`.
- **A is wrong**: `ARG` can be placed after `FROM`.
- **B is partially correct**: But “anywhere” could be after `RUN`, which causes
  the error.
- **C is wrong**: Form of `RUN` doesn't cause this issue.

---

### ✅ **Question 3**

**Which command lists available container images?**

**Options:**

- A) docker image build
- B) docker load
- C) docker run
- D) docker image ls ✅

**Correct Answer: D**

**Explanation:**

- **Correct**: `docker image ls` lists all images stored locally.
- **A** builds an image.
- **B** loads an image from tarball.
- **C** runs a container.

---

### ✅ **Question 4**

**Which command builds a Docker image from a Dockerfile?**

**Options:**

- A) docker image build ✅
- B) docker run
- C) docker image ls
- D) docker save

**Correct Answer: A**

**Explanation:**

- **Correct**: `docker image build` is the command to create an image.
- **B** starts a container.
- **C** lists images.
- **D** saves images to tar files.

---

### ✅ **Question 5**

**Which `FROM` statement pulls Postgres version 15 image?**

**Options:**

- A) FROM postgres
- B) FROM postgres-15
- C) FROM postgres:15 ✅
- D) FROM postgres\:latest

**Correct Answer: C**

**Explanation:**

- **Correct**: `postgres:15` specifies the version explicitly.
- **A** could pull latest by default — but version isn't fixed.
- **B** is not a valid tag.
- **D** is ambiguous and could break builds in future.

---

### ✅ **Question 6**

**You want the smallest Docker image for your self-contained Golang app. Which
`FROM` helps?**

**Options:**

- A) FROM ubuntu\:tiny
- B) FROM scratch ✅
- C) FROM none
- D) FROM alpine

**Correct Answer: B**

**Explanation:**

- **Correct**: `scratch` creates an image from nothing — best for self-contained
  apps.
- **A and D** are larger than `scratch`.
- **C** is invalid Docker syntax.

---

### ✅ **Question 7**

**Why must `FROM` be the first line in Dockerfile?**

**Options:**

- A) because of limitations within the Dockerfile parser in containerd
- B) because FROM completes more quickly than other commands
- C) because they define the base image from which your new image will be
  created ✅

**Correct Answer: C**

**Explanation:**

- **Correct**: Docker must know the base image before executing other
  instructions.
- **A** is partially true but too low-level.
- **B** is incorrect reasoning.

---

### ✅ **Question 8**

**Each command in Dockerfile is \_\_\_\_\_. The result of each command is
\_\_\_\_\_.**

**Options:**

- A) executed in an intermediate container; an image layer ✅
- B) an image layer; executed in a permanent container
- C) an image layer; executed in an intermediate container
- D) executed in a permanent container; an image layer

**Correct Answer: A**

**Explanation:**

- **Correct**: Docker executes each instruction in a temp container and commits
  the result as a layer.
- Other options confuse the lifecycle.

---

### ✅ **Question 9**

**What happens with: `RUN chmod -R 0600 /app`?**

**Options:**

- A) Docker will interpret this as a syntax error.
- B) Each word will be interpreted as individual Dockerfile commands.
- C) `chmod -R 0600 /app` will be provided as arguments to RUN ✅
- D) Docker will interpret this as a comment.

**Correct Answer: C**

**Explanation:**

- **Correct**: Shell form of `RUN` treats entire string as shell command.
- Others misinterpret Dockerfile parsing rules.

---

### ✅ **Question 10**

**Best Dockerfile to package a minimal app with multi-stage and run as
`nobody`?**

**Options:**

- A) FROM alpine...
- B) FROM scratch...
- C) FROM ubuntu with strip and adduser
- D) FROM ubuntu... FROM scratch... ✅

**Correct Answer: D**

**Explanation:**

- **Correct**: Build in Ubuntu, copy only binary to scratch, use `USER nobody` —
  smallest and most secure.
- A and C leave dependencies.
- B fails because build can’t happen in `scratch`.

---

### ✅ **Question 11**

**What problem do Dockerfiles solve?**

**Options:**

- A) Automate creating and describing container images ✅
- B) Retrieve images from registries
- C) Install Docker
- D) Decompress layers and form images

**Correct Answer: A**

**Explanation:**

- **Correct**: Dockerfile describes repeatable image build steps.
- Others refer to Docker CLI functions, not Dockerfiles.

---

### ✅ **Question 12**

**Copy file `/etc/nginx/nginx.conf` from nginx\:latest using multi-stage
build.**

**Options:**

- A) docker container create...docker cp...
- B) Not possible
- C) COPY nginx\:latest:/etc/nginx/nginx.conf
- D) COPY --from=nginx\:latest /etc/nginx/nginx.conf ✅

**Correct Answer: D**

**Explanation:**

- **Correct**: `--from=` allows pulling from external images.
- A is older workaround.
- B and C are incorrect Dockerfile syntax.

---

### ✅ **Question 13**

**Which is _not_ an advantage of multi-stage builds?**

**Options:**

- A) Smaller secure images
- B) Build speedup
- C) Strip image to minimum
- D) Write Dockerfiles as bash scripts ✅

**Correct Answer: D**

**Explanation:**

- **Correct**: Dockerfiles are _not_ bash scripts.
- Others are real benefits.

---

### ✅ **Question 14**

**Best way to add contact info in a Dockerfile?**

**Options:**

- A) COMMENT "Contact me..."
- B) MAINTAINER "..."
- C) LABEL maintainer="..." ✅
- D) # Contact me...

**Correct Answer: C**

**Explanation:**

- **Correct**: `LABEL` is current best practice.
- **B** is deprecated.
- A and D are invalid/ignored by Docker.

---

### ✅ **Question 15**

**Which is false about this Dockerfile snippet with multiple `USER`, `RUN`,
`ENTRYPOINT`, `CMD`, and `EXPOSE`?**

**Options:**

- A) Port 8080 must be exposed manually ✅
- B) update-ca-certificates needs sudo
- C) server.py runs as root
- D) --development flag is forced

**Correct Answer: A**

**Explanation:**

- **Correct**: EXPOSE doesn’t publish the port; you need `-p` or `--publish`.
- B is wrong: it runs as root.
- C is wrong: USER is switched.
- D is wrong: CMD is overrideable.

---

### ✅ **Question 16**

**Correct way to create and switch to database user?**

**Options:**

- A) USER database RUN useradd
- B) USER root RUN useradd
- C) USER root RUN useradd... USER database ✅
- D) RUN change_user

**Correct Answer: C**

**Explanation:**

- **Correct**: You must be root to create user, then switch.
- A and B switch too early.
- D is invalid.

---

### ✅ **Question 17**

**Why does `--production` argument not work in this Python app?**

**Options:**

- A) ENTRYPOINT is shell form ✅
- B) Missing ENTRYPOINT
- C) CMD overrides args
- D) ENTRYPOINT uses args

**Correct Answer: A**

**Explanation:**

- **Correct**: Shell form routes args into `sh -c`, not Python.
- B is wrong: ENTRYPOINT exists.
- C and D confuse arg flow.

---

### ✅ **Question 18**

**Why can’t you CTRL+C a Node app in Docker?**

**Options:**

- A) ENTRYPOINT is exec, app ignores signal
- B) ENTRYPOINT is shell, CTRL-C discarded ✅
- C) Interactive mode discards signals
- D) Pseudo-TTY causes discard

**Correct Answer: B**

**Explanation:**

- **Correct**: Shell form doesn’t forward signals — must use exec or tini.
- Others are either unrelated or incorrect.

---

### ✅ **Question 19**

**\_\_\_\_\_ defines the default program that containers run. \_\_\_\_\_
provides default arguments to \_\_\_\_\_.**

**Options:**

- A) ENTRYPOINT, CMD, ARG
- B) ENTRYPOINT, CMD, ENTRYPOINT ✅
- C) CMD, ENTRYPOINT, ARG
- D) CMD, ENTRYPOINT, CMD

**Correct Answer: B**

**Explanation:**

- **Correct**: CMD gives args to ENTRYPOINT.
- Others either mix up order or include `ARG`, which is for build-time.

---
