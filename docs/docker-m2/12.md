---
title: Diving Deeper into Docker Images [Part 2]
sidebar_position: 38
---------------------

## Introduction

In the previous section, we explored the `manifest.json` and configuration file of a Docker image. Now, we take a closer look at **image layers**, the `json` metadata per layer, and how the runtime combines these to form the container's file system.

---

## Exploring the Layer Files

When listing the contents of `hello-world.tar.gz`:

```bash
tar -tf ./hello-world.tar.gz
```

You’ll see entries such as:

- `1fa3.../layer.tar`
- `1fa3.../json`
- `1fa3.../VERSION`
- `4e5f.../layer.tar`
- `4e5f.../json`
- `4e5f.../VERSION`

---

## Layer Metadata (`json`)

Extract one of the `json` files:

```bash
tar -xO -f hello-world.tar.gz 1fa3.../json | jq .
```

### Key Properties:

- **id** The unique identifier (hash) for this layer.

- **parent** Present for all but the topmost layer. Indicates the layer
  hierarchy and order.

> The `parent` property allows the runtime to link layers together in sequence.

---

## The `VERSION` File

Each layer directory contains a `VERSION` file:

```bash
tar -xO -f hello-world.tar.gz 1fa3.../VERSION
```

Output:

```
1.0
```

- Always contains `1.0`.
- Used by Docker to validate image format compatibility.

---

## Layer Ordering

- The **last layer** in the image appears **first** in the `manifest.json` list.
- Layers are applied from **base to top**:

  - Parent → Child → Final layer.

---

## Inspecting `layer.tar`

To list the contents of a `layer.tar` without extracting to disk:

```bash
tar -xO -f hello-world.tar.gz 1fa3.../layer.tar | tar -tf -
```

> The `-` tells `tar` to read the tar file from the pipe.

### Example Output:

```
hello-from-linkedin-learning
```

Inspecting the second layer:

```bash
tar -xO -f hello-world.tar.gz 4e5f.../layer.tar | tar -tf -
```

### Example Output:

```
hello
```

---

## Combining Layers

- **Each layer adds or modifies files** in the image’s file system.
- When combined:

  - Container will have both:

    - `/hello`
    - `/hello-from-linkedin-learning`

> This shows how even tiny layers can build a complete container file system.

---

## Space Efficiency

- These sample layers are extremely small (single files).

- Real images include base OS layers (e.g., `/bin`, `/lib`, `/etc`).

- Layering allows:

  - Reuse of common base layers.
  - Minimal changes per image version.

---

## Key Insights

- Docker images are stacks of compressed layers.
- `json` files define layer metadata and parent relationships.
- `VERSION` ensures compatibility.
- The runtime unpacks layers in order to create the container’s root file
  system.

---

## Questions and Answers

### Q1: What does the `parent` field in a layer's JSON represent?

**A:** It links the current layer to the layer beneath it, defining build order.

---

### Q2: Why does Docker use multiple layers instead of a single tarball?

**A:** Layers allow caching, deduplication, and incremental builds.

---

### Q3: What is the purpose of the `VERSION` file?

**A:** Ensures the image layer format is compatible with the runtime. Always
contains `1.0`.

---

### Q4: How do layer changes reflect in containers?

**A:** Combined layers form the container’s root file system; each new layer
adds/modifies files.

---

### Q5: Which layer is applied first when building the container file system?

**A:** The base layer (without a `parent` field) is applied first, followed by
child layers in sequence.
