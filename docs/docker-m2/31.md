---

title: Challenge – Build and Run Your First Image
sidebar_position: 57
---------------------

## 🧪 Challenge: Fix, Build, and Run a Broken Dockerfile

> You've been given a **broken Dockerfile** and the **source code for a Go app**. Your mission is to:

* **Fix the Dockerfile**
* **Build the image**
* **Run the container**
* **Verify the app works**

---

## 🧱 Step-by-Step Instructions

### 1. 📦 Clone or download the exercise folder

Assume you already have a directory like this:

```
challenge/
├── Dockerfile   ← broken file
└── main.go      ← Go source code
```

---

### 2. 🔧 Fix the Broken Dockerfile

The Dockerfile is incomplete or misordered.

Use this **working version** of the Dockerfile for a basic Go app:

```Dockerfile
# Stage 1 – Build the Go binary
FROM golang:1.20-alpine AS builder

WORKDIR /app

COPY . .

RUN go build -o test-app main.go

# Stage 2 – Create a minimal final image
FROM scratch

COPY --from=builder /app/test-app /test-app

ENTRYPOINT ["/test-app"]
```

> ✅ This is a **multi-stage build** (extra credit included!)

---

### 3. 🏗️ Build the Docker Image

```bash
docker build -t go-test-app .
```

> 🔍 If the build fails, carefully read the error and check:
>
> - Are all `COPY` statements correct?
> - Is `go build` targeting the right file?
> - Are you missing the build context (`.` at the end)?

---

### 4. 🚀 Run the Container

```bash
docker run --rm go-test-app
```

This will:

- Execute the `/test-app` binary inside a scratch container
- Print output like:

```
Congrats! You’ve completed the challenge!
```

---

## 💡 Tips & Hints

| Tip                                    | Explanation                                      |
| -------------------------------------- | ------------------------------------------------ |
| You **don’t need to modify** `main.go` | All logic is handled by the app already          |
| ✅ Use a **multi-stage build**         | Keeps the final image minimal, clean, and secure |
| 📁 Final image uses `scratch`          | No OS, no shell, no bash – just your app binary  |
| 🐳 `docker build .` needs the `.`      | That dot provides the build context (important!) |

---

## 🧠 Why Use Multi-Stage Builds?

| Traditional Build   | Multi-Stage Build                  |
| ------------------- | ---------------------------------- |
| Large image size    | Lightweight (few MBs)              |
| Exposes build tools | No Go, no OS in final image        |
| Less secure         | More secure: fewer attack surfaces |
| Harder to maintain  | Easier to test and audit           |

---

### 📸 Visual Overview

![Multi-stage Dockerfile flow](https://docs.docker.com/build/images/multistage.png)

---

## ❓Q\&A

### Q1: Why do we use `scratch`?

**Answer**: `scratch` is a special empty base image used to create **minimal
containers**. It has:

- No shell
- No libraries
- No OS

Perfect for **Go binaries** which are fully statically linked.

---

### Q2: What does `--from=builder` do?

**Answer**: It copies files **from a previous stage** (`AS builder`) into the
final image. This is the essence of **multi-stage builds**.

---

### Q3: Why is the build context important (`.` in `docker build .`)?

**Answer**: The `.` sends **all files in the current directory** into the Docker
daemon to be used by `COPY`. Without it, Docker won’t find `main.go`, and `COPY`
will fail.

---

### Q4: Why is this approach more secure?

**Answer**: Because:

- No unnecessary tools or shells in the final image
- Minimal attack surface
- Easier to scan and verify for vulnerabilities

---

## 🏁 Summary

| Step              | Task                            |
| ----------------- | ------------------------------- |
| ✅ Fix Dockerfile | Multi-stage with Go             |
| ✅ Build image    | `docker build -t go-test-app .` |
| ✅ Run container  | `docker run --rm go-test-app`   |
| ✅ Verify output  | Success message shown           |

> You just built and ran your first secure, multi-stage Go container image!

---
