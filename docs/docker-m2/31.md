---

title: Challenge â€“ Build and Run Your First Image
sidebar_position: 57
---------------------

## ğŸ§ª Challenge: Fix, Build, and Run a Broken Dockerfile

> You've been given a **broken Dockerfile** and the **source code for a Go app**. Your mission is to:

* **Fix the Dockerfile**
* **Build the image**
* **Run the container**
* **Verify the app works**

---

## ğŸ§± Step-by-Step Instructions

### 1. ğŸ“¦ Clone or download the exercise folder

Assume you already have a directory like this:

```
challenge/
â”œâ”€â”€ Dockerfile   â† broken file
â””â”€â”€ main.go      â† Go source code
```

---

### 2. ğŸ”§ Fix the Broken Dockerfile

The Dockerfile is incomplete or misordered.

Use this **working version** of the Dockerfile for a basic Go app:

```Dockerfile
# Stage 1 â€“ Build the Go binary
FROM golang:1.20-alpine AS builder

WORKDIR /app

COPY . .

RUN go build -o test-app main.go

# Stage 2 â€“ Create a minimal final image
FROM scratch

COPY --from=builder /app/test-app /test-app

ENTRYPOINT ["/test-app"]
```

> âœ… This is a **multi-stage build** (extra credit included!)

---

### 3. ğŸ—ï¸ Build the Docker Image

```bash
docker build -t go-test-app .
```

> ğŸ” If the build fails, carefully read the error and check:
>
> - Are all `COPY` statements correct?
> - Is `go build` targeting the right file?
> - Are you missing the build context (`.` at the end)?

---

### 4. ğŸš€ Run the Container

```bash
docker run --rm go-test-app
```

This will:

- Execute the `/test-app` binary inside a scratch container
- Print output like:

```
Congrats! Youâ€™ve completed the challenge!
```

---

## ğŸ’¡ Tips & Hints

| Tip                                    | Explanation                                      |
| -------------------------------------- | ------------------------------------------------ |
| You **donâ€™t need to modify** `main.go` | All logic is handled by the app already          |
| âœ… Use a **multi-stage build**         | Keeps the final image minimal, clean, and secure |
| ğŸ“ Final image uses `scratch`          | No OS, no shell, no bash â€“ just your app binary  |
| ğŸ³ `docker build .` needs the `.`      | That dot provides the build context (important!) |

---

## ğŸ§  Why Use Multi-Stage Builds?

| Traditional Build   | Multi-Stage Build                  |
| ------------------- | ---------------------------------- |
| Large image size    | Lightweight (few MBs)              |
| Exposes build tools | No Go, no OS in final image        |
| Less secure         | More secure: fewer attack surfaces |
| Harder to maintain  | Easier to test and audit           |

---

### ğŸ“¸ Visual Overview

![Multi-stage Dockerfile flow](https://docs.docker.com/build/images/multistage.png)

---

## â“Q\&A

### Q1: Why do we use `scratch`?

**Answer**: `scratch` is a special empty base image used to create **minimal
containers**. It has:

- No shell
- No libraries
- No OS

Perfect for **Go binaries** which are fully statically linked.

---

### Q2: What does `--from=builder` do?

**Answer**: It copies files **from a previous stage** (`AS builder`) into the
final image. This is the essence of **multi-stage builds**.

---

### Q3: Why is the build context important (`.` in `docker build .`)?

**Answer**: The `.` sends **all files in the current directory** into the Docker
daemon to be used by `COPY`. Without it, Docker wonâ€™t find `main.go`, and `COPY`
will fail.

---

### Q4: Why is this approach more secure?

**Answer**: Because:

- No unnecessary tools or shells in the final image
- Minimal attack surface
- Easier to scan and verify for vulnerabilities

---

## ğŸ Summary

| Step              | Task                            |
| ----------------- | ------------------------------- |
| âœ… Fix Dockerfile | Multi-stage with Go             |
| âœ… Build image    | `docker build -t go-test-app .` |
| âœ… Run container  | `docker run --rm go-test-app`   |
| âœ… Verify output  | Success message shown           |

> You just built and ran your first secure, multi-stage Go container image!

---
