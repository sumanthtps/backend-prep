---
title: Diving Deeper into Docker Images [Part 1]
sidebar_position: 37
---

## Introduction

In this section, we explore the internal structure of a Docker image by
inspecting the contents of a saved `hello-world.tar.gz` file. This helps
understand how layers, manifests, and configuration files make up an image.

---

## Inspecting the Image File

### 1. Listing Contents

To view the contents of the Docker image archive without extracting:

```bash
tar -tf ./hello-world.tar.gz
```

### Expected Files:

- `manifest.json` – Describes image layers and tags.
- `repositories` – Stores image name and tag mapping.
- One or more `layer.tar` files – Represent image layers.
- A JSON file with a long ID – Image configuration.

---

## Exploring `manifest.json`

Extract and view the manifest without writing to disk:

```bash
tar -xO -f hello-world.tar.gz manifest.json | jq .
```

### Key Fields:

- **Config** Points to the image’s configuration JSON file.
- **RepoTags** Lists image names and tags, e.g., `hello-world:v1`.
- **Layers** Ordered list of `layer.tar` files making up the image.

> The manifest acts as a blueprint for how the runtime assembles layers.

---

## Inspecting the Config File

Use the ID from the `Config` field to view the image configuration:

```bash
tar -xO -f hello-world.tar.gz <config-file>.json | jq .
```

### Important Fields:

- **architecture** CPU architecture the image was built for (e.g., `amd64`,
  `arm64`).

  - Containers inherit this architecture.
  - You cannot run ARM binaries on x86_64 hosts without emulation.

- **os** Operating system the image targets (e.g., `linux`, `windows`).

  - Linux containers need a Linux kernel.
  - Windows containers require the Windows kernel.

- **container_config** Configuration of the container that built the last image
  layer.

- **config** Configuration inherited by containers created from this image:

  - Entrypoint
  - Environment variables
  - Working directory

- **history** The build history and commands used to create the image layers.

---

## Layers Recap

- Each `layer.tar` is a **compressed file system delta**.
- When combined, they form the container’s root file system.
- The runtime adds a **writable layer** on top for container changes.

---

## Key Insights

- Docker images are essentially **compressed tar archives** with a manifest and
  configuration.
- The **manifest** ties layers together and defines image tags.
- The **config file** defines runtime settings for containers built from the
  image.
- Architecture and OS fields ensure compatibility with the host system.

---

## Questions and Answers

### Q1: Can you run an ARM image on an Intel machine?

**A:** Not directly. You need emulation (e.g., QEMU via Docker’s `--platform`
option).

---

### Q2: What is the difference between `container_config` and `config`?

**A:**

- `container_config` → Settings used when building the image’s last layer.
- `config` → Settings inherited by containers created from the image.

---

### Q3: Why is `history` useful?

**A:** It shows how the image was built, which helps in auditing unknown or
third-party images.

---

### Q4: What happens if `os` doesn’t match the host kernel?

**A:** The container will not run. Linux images need a Linux kernel; Windows
images need a Windows kernel.

---

### Q5: Why are image layers separate files?

**A:** Layers enable caching and deduplication across images, making them
efficient for storage and distribution.
