---

title: Multi-Platform Images in Docker
sidebar_position: 55
---------------------

## üåç Why Multi-Platform Images Matter

### ‚úÖ Key Insight:

Container images are **platform-specific** by default.

### üö´ Limitations:

* Docker images **built on x86\_64** (Intel/AMD) won't run on **ARM64** (Apple Silicon, Graviton, Ampere).
* Processor **instruction sets** (ISA) are different ‚Äî like speaking different machine languages.

---

## üí° Example: Architecture-Specific Execution

```bash
uname -a
# Output: x86_64 (Intel-based)

docker run --rm alpine uname -a
# Output: x86_64 (inherits host architecture)
```

But what if we try to run **ARM64 image** on an Intel machine?

```bash
docker run --rm --platform linux/arm64 alpine uname -a
```

### ‚ùå Error:

```
exec format error
```

This means: the CPU doesn‚Äôt understand ARM64 machine code.

---

## üß† Why This Happens

Each CPU has its own **Instruction Set Architecture (ISA)**:

| Processor    | ISA    |
| ------------ | ------ |
| Intel/AMD    | x86_64 |
| Apple M1/M2  | arm64  |
| AWS Graviton | arm64  |

Your Docker image gets compiled to machine code using a **specific ISA**. If you
try to run a program for another ISA, Linux throws an `exec format error`.

---

## ‚úÖ Solution: Emulating Architectures

### Step 1: Use QEMU + BINFMT

**QEMU** = Open source CPU emulator **BINFMT** = Binary Format Handlers in Linux

These allow your system to:

- Detect when you're trying to run foreign architecture binaries
- Automatically forward them to QEMU for emulation

---

## üîß Enable QEMU via Docker

```bash
docker run --privileged --rm aptman/qus --static -- --path arm
```

### ‚ö†Ô∏è Why `--privileged` is dangerous:

- Grants full access to host devices
- Use **only for trusted containers**
- Required here to register the emulator system-wide

### ‚úÖ Output:

You‚Äôll see registrations like:

```
Registered binary format: arm
Registered binary format: arm64
...
```

---

## üõ†Ô∏è Install QEMU on Host (Mac/Linux)

If you're using Docker Desktop on Mac (Apple Silicon or Intel):

```bash
# On your Linux VM (e.g., Lima)
sudo apt -y update
sudo apt -y install qemu qemu-user-static qemu-user qemu-system-misc binfmt-support
```

Then exit the VM and go back to terminal.

---

## ‚úÖ Smoke Test

Try running an ARM image:

```bash
docker run --rm --platform linux/arm64 alpine uname -a
```

### Expected:

```
Linux hostname ... aarch64
```

If it fails:

- QEMU isn‚Äôt installed properly
- Emulator not registered via binfmt

---

## üß± Building Multi-Platform Images

You can **manually** build separate images:

### üî® Build for x86:

```bash
docker build --pull --platform linux/amd64 -t my-image:latest-x86 .
```

### üî® Build for ARM:

```bash
docker build --pull --platform linux/arm64 -t my-image:latest-arm .
```

### üìù Why `--pull` is important:

- Ensures you pull correct **base image** for target architecture

---

## üèÅ Run Platform-Specific Images

```bash
docker run --rm my-image:latest-x86
docker run --rm my-image:latest-arm
```

Thanks to `binfmt_misc` + QEMU, this **just works**, even on mismatched
hardware.

---

## üßô‚Äç‚ôÇÔ∏è Transparent Emulation (binfmt)

```bash
# The binary handler intercepts ARM64 calls
/binfmt_misc/qemu-aarch64
```

Linux transparently routes the ARM64 entrypoint binary to QEMU, **no changes
needed in your Dockerfile**.

---

## üê¢ Performance Caveat

- Emulation ‚â† Native speed
- QEMU = slower (because of instruction translation)
- Expect **longer build and run times** for non-native platforms

---

## ü§ù Manifest List (Coming in Chapter 9)

Once you have separate builds:

- `my-image:latest-x86`
- `my-image:latest-arm`

You can link them into **one multi-platform image** using a **manifest list**.

This allows users to pull the right version **automatically**:

```bash
docker pull my-image:latest  # gets correct arch version
```

---

## üìå Summary Table

| Feature                  | Without QEMU / Multi-Platform | With QEMU & Multi-Platform |
| ------------------------ | ----------------------------- | -------------------------- |
| Cross-architecture build | ‚ùå                            | ‚úÖ                         |
| Runs ARM image on Intel? | ‚ùå `exec format error`        | ‚úÖ Emulated via QEMU       |
| Transparent emulation    | ‚ùå                            | ‚úÖ via binfmt_misc         |
| Native performance       | ‚úÖ                            | ‚ùå (QEMU slower)           |
| Manifest support         | ‚ùå (manual tagging)           | ‚úÖ (via `docker manifest`) |
| Registry compatible      | ‚úÖ                            | ‚úÖ                         |

---

## ‚ùì Questions and Answers

### Q1: Why can‚Äôt I run an ARM image on Intel without QEMU?

Because **ISAs are not compatible** ‚Äî ARM binaries can‚Äôt run on x86 CPUs.

---

### Q2: Why do we get an `exec format error`?

That‚Äôs Linux telling you:

> "I don‚Äôt know how to run this binary."

---

### Q3: How is QEMU involved?

QEMU **emulates** ARM instructions so your x86 CPU can understand and run them.
It‚Äôs like a live translator between different CPU languages.

---

### Q4: Do I need to change my Dockerfile?

**No.** With `binfmt_misc` + QEMU, your existing Dockerfiles will work with:

```bash
docker build --platform ...
```

---

### Q5: How do I create a single image that supports both ARM and x86?

Use `docker manifest create` and `docker manifest push` (This is covered in
**Chapter 9**)

---

## üîç Key Takeaways

- Use `--platform` flag to build or run images for alternate architectures
- Register QEMU and binfmt_misc to enable transparent emulation
- Build platform-specific images using `--platform`
- Use `--pull` to ensure correct base image for that platform
- Use `docker manifest` to unify multiple architectures into one tag

---
