---

title: Docker Images – The Blueprint of Containers
sidebar_position: 36
---------------------

## Introduction

Containers need a **file system and environment** to run applications. This is provided by **Docker images**, which act as the blueprint for creating containers. Every container you run is based on an image.

---

## What are Docker Images?

- A **read-only template** that contains:

  - File system snapshot
  - Application binaries
  - Dependencies and libraries
  - Configuration instructions

- Used by the container runtime to create containers.

> **Analogy:** Docker images are like virtual machine disk snapshots. Containers
> are like the running VMs created from those disks.

---

## How Images Work with Containers

1. The runtime **extracts** the image’s contents into a new directory.
2. It uses **chroot + namespaces** to make that directory the container’s root
   (`/`).
3. A **read-write layer** is added on top of the image for the running
   container.

---

## Anatomy of a Docker Image

### 1. **Compressed Archive**

- Usually a `.tar.gz` (tarball + gzip).
- May use other compression formats like **zstd** for efficiency.

### 2. **Layers**

- Each image consists of **one or more layers**:

  - Each layer is a compressed archive of files.
  - Layers stack to form the full file system.

- The last layer often includes metadata or startup configuration.

> Layers make images efficient: unchanged layers are reused across images and
> containers.

### 3. **Manifest**

- A JSON file at the root of the image.
- Describes:

  - Layers and their order.
  - Configurations (entrypoint, env vars, etc.).

- Container runtime uses it as the **blueprint** for creating containers.

---

## Example: Inspecting an Image

```bash
# Save an image as a tarball
docker pull nginx
docker save nginx -o nginx.tar

# Extract the tarball
tar -xvf nginx.tar

# You'll see files like:
# manifest.json
# layer.tar (multiple layers)
```

---

## Layers and Reuse

- Layers are identified by **hashes**.
- Shared layers between images are stored **only once** on disk.
- Example:

  - `python:3.11` and `python:3.11-slim` share the same base OS layer.

---

## Creating a Container from an Image

```bash
docker run nginx
```

- Docker pulls the `nginx` image.
- `containerd` extracts layers to `/var/lib/docker`.
- `runc` creates a container using those layers as the root file system.

---

## Summary

- **Images = Blueprint**; **Containers = Running instances**.
- Images are **compressed tarballs** made of layers.
- Layers allow efficient storage and caching.
- A manifest defines how layers combine and how the container is configured.

---

## Questions and Answers

### Q1: Are Docker images the same as containers?

**A:** No. Images are static, read-only templates. Containers are runtime
instances of images with a writable layer.

---

### Q2: Why are images layered?

**A:** Layers allow caching, reusability, and efficient storage. Shared layers
are stored only once.

---

### Q3: What is the purpose of the manifest?

**A:** It tells the runtime how to assemble layers and configure the container.

---

### Q4: Can I create my own Docker image?

**A:** Yes. Using a `Dockerfile`, you can build custom images with:

```bash
docker build -t myapp .
```

---

### Q5: Why are images compressed?

**A:** To reduce size, speed up transfers, and make them portable across
registries and systems.
