---

title: Multi-Stage Builds in Docker
sidebar_position: 54
---------------------

## üöÄ Overview

**Multi-stage builds** are an advanced feature in Docker that allow you to:

* Optimize final image size
* Improve security
* Reduce build times
* Keep Dockerfiles clean and maintainable

This concept replaces older patterns like the **builder pattern**, which required manual copying between temporary containers and images.

---

## üß† Problem: Large Docker Images

Consider this:

- Your app might be **just a few kilobytes**, but your Docker image is
  **hundreds of megabytes**.
- Most of this size comes from unnecessary tools, dependencies, and base image
  bloat.

### Example:

```bash
App size:          876 bytes
Image size:        ~100 MB
Multiplier:        135,000x larger than the app
```

**Why?**

- Ubuntu base images come with many utilities you don‚Äôt use
- Layers stack up during image build (especially `RUN apt install ...`)

---

## üõ† The Legacy Approach: The Builder Pattern

### Steps:

1. Create a **build Dockerfile** (e.g. based on Ubuntu)
2. Create a **runtime Dockerfile** (e.g. based on Alpine)
3. Run first `docker build`
4. Use `docker create` and `docker cp` to extract the built artifacts
5. Run second `docker build` using those artifacts

### ‚ùå Problems:

- **Two Dockerfiles** to manage
- Manual steps to extract/copy files
- Leftover **temporary images** and **containers**
- Risk of **forgetting to clean up**
- Prone to **errors in CI/CD**

---

## ‚úÖ Solution: Multi-Stage Builds

### What are they?

A **single Dockerfile** with **multiple `FROM` statements**. Each `FROM` block
is a **stage**. Only the **final stage** becomes your production image.

---

## üîÅ Syntax Overview

```dockerfile
# Stage 1: Build artifacts
FROM ubuntu:latest AS builder
RUN curl -s google.com > /tmp/date.txt

# Stage 2: Final lightweight image
FROM alpine:3.16
COPY --from=builder /tmp/date.txt /app/include/date.txt
CMD ["cat", "/app/include/date.txt"]
```

### üí° Notes:

- Use `AS builder` to name the stage
- `COPY --from=builder` grabs only what you need
- Final image includes just your app and essentials

---

## ‚úÖ Benefits of Multi-Stage Builds

### 1. **Smaller Image Sizes**

- Final image includes **only runtime dependencies**
- Can switch from `ubuntu` (100MB+) to `scratch` or `busybox` (\~1MB)

### 2. **Improved Security**

- Fewer libraries = smaller attack surface
- No need to patch `curl`, `gcc`, `make`, etc., in runtime image

### 3. **Better Performance**

- Cache-friendly layer separation
- You copy the app only once‚Äîno `RUN` commands rerun if unchanged

### 4. **Cleaner Dockerfile**

- All logic is in one file
- Easy to read and debug

---

## üîß Advanced Features

### ‚úÖ Using Stage Index vs Alias

```dockerfile
COPY --from=0 /output /app/output     # stage 0
COPY --from=builder /output /app/output  # better
```

### ‚úÖ Copying from External Images

```dockerfile
COPY --from=some/existing:image /tools/bin /usr/local/bin
```

This allows reuse of prebuilt binaries or scripts.

### ‚úÖ Reusing Stages

```dockerfile
FROM builder AS test
RUN echo "Running tests"

FROM builder AS linter
RUN echo "Running linter"
```

---

## üîç Sample Dockerfile with Multi-Stage Build

```dockerfile
# Stage 1: Builder
FROM ubuntu:22.04 AS builder
RUN apt-get update && apt-get install -y curl
RUN curl -s google.com > /app/include/date.txt

# Stage 2: Runtime
FROM alpine:3.16 AS app
WORKDIR /app
COPY app.sh .
COPY --from=builder /app/include/date.txt ./include/date.txt
ENTRYPOINT ["/bin/sh", "app.sh"]
CMD ["--default"]
```

---

## ‚ùì FAQ: Why Not Just Use Alpine?

> "Why not just base everything on Alpine and avoid all this?"

‚úÖ You can, **but**:

- You may need packages only available in Ubuntu
- Some tools (e.g. `curl`, `gcc`) are easier to install in Debian-based images
- Using Alpine as a final stage + Ubuntu as build stage is **the best of both
  worlds**

---

## üß™ Real-World Optimization

Using `busybox` instead of `alpine` or `ubuntu`:

```dockerfile
FROM busybox:uclibc
COPY app.sh /app.sh
ENTRYPOINT ["/app.sh"]
```

**Final size: \~13 MB**

> Vs original Ubuntu-based image: \~100+ MB

---

## üß† Summary

| Feature                | Builder Pattern     | Multi-Stage Builds        |
| ---------------------- | ------------------- | ------------------------- |
| Multiple Dockerfiles?  | Yes                 | No                        |
| Manual cleanup needed? | Yes                 | No                        |
| Hard to automate?      | Yes                 | No                        |
| Easy to maintain?      | No                  | Yes                       |
| Final image size       | Moderate            | Minimal (app + deps only) |
| Security               | Exposes build tools | Final image is clean      |

---

## ‚úÖ Key Takeaways

- Use **multi-stage builds** to create secure, optimized images
- Only include what's needed to run your app
- Keep your build logic and runtime logic **in a single Dockerfile**
- Copy from other stages using `--from=stage-name` for clarity
- Great for CI/CD pipelines and production-grade containers

---

## ‚ùì Questions and Answers

### Q1: What happens to intermediate stages?

They are **discarded automatically** after the final image is built. No cleanup
needed.

---

### Q2: Can I use multiple `COPY --from=...`?

Yes, you can copy **multiple files or directories** from any named stage.

---

### Q3: Do I need to install tools like `curl` in every stage?

No. Install heavy tools **only in build stage**, and **copy results** into final
stage.

---

### Q4: Can I copy from an image that's not in my Dockerfile?

Yes. Example:

```dockerfile
COPY --from=ghcr.io/org/toolkit:latest /bin/tool /usr/bin/tool
```

---

### Q5: Can I use `scratch` with multi-stage builds?

Yes. Example:

```dockerfile
FROM golang:1.21 AS builder
WORKDIR /build
COPY . .
RUN go build -o app

FROM scratch
COPY --from=builder /build/app /app
ENTRYPOINT ["/app"]
```

This produces the **smallest possible container**.

---

## üìÇ Explore Further

- Try the `tiny.Dockerfile` in the exercise files
- Use tools like `dive` to analyze image layers
- Challenge: Create a container image under **10 MB**

---
