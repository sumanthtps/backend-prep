---

id: exposing-container-ports
title: Exposing Container Ports Between Containers
sidebar_label: Exposing Container Ports
sidebar_position: 71
---------------------

## Summary

Docker allows containers to expose ports to the host and to other containers — even across isolated networks. This section demonstrates how publishing ports enables cross-container communication using a TCP echo server created via Netcat and accessed using Telnet.

## Key Concepts

### Port Communication Breakdown

* **Container A** starts a simple TCP server using Netcat: `nc -l -p 80`
* **Container B** attempts to connect using Telnet
* Containers on **different bridge networks** cannot connect directly

### Problem

Even though port 80 is open in Container A, Container B (on a different Docker bridge network) cannot reach it because bridge networks are **logically isolated**.

### Solution: Publishing Ports

Docker enables **port publishing** using the `--publish` (or `-p`) flag:

```
--publish HOST_PORT:CONTAINER_PORT
```

* Example: `--publish 8080:80`
* 8080 is on the host; 80 is inside the container
* This configures Docker’s `iptables` NAT to forward traffic

### Use Case: Host and Cross-Network Communication

* Other containers (like B) can connect using **host’s bridge gateway IP** (`172.18.0.1:8080`)
* Host machine can access it via **localhost:8080**

## Diagram: Cross-Container Port Publishing

![Port publishing from container to host](https://raw.githubusercontent.com/docker/labs/master/networking/images/port-publishing.png)

*Source: [Docker Labs](https://github.com/docker/labs/blob/master/networking/)*

## Bridge Gateway Lookup

To identify the gateway IP inside a container:

```bash
ip route
```

This will return something like:

```
default via 172.18.0.1 dev eth0
```

## Why Not Use Port 80?

* **Privileged Ports (<1024)** require root privileges inside the container
* To avoid permission issues, use high-numbered ports like **8080**, **5000**, **1234**

## Real-World Analogy

Port publishing in Docker is like **port forwarding on a home router**: external traffic on a router port is redirected to a specific internal device and port.

---

## Missing Improvements

| Topic                        | What Was Missing                                                                             |
| ---------------------------- | -------------------------------------------------------------------------------------------- |
| Multi-port exposure          | `--publish-all` (`-P`) could be demonstrated                                                 |
| Real web server demo         | Use of `nginx` or `httpd` as real-world port publishers                                      |
| Docker Desktop clarification | Diagram to show how VPNKit/HyperKit handle port forwarding for Mac/Windows                   |
| Custom networks              | Better clarity on using DNS when publishing ports inside custom user-defined bridge networks |

---

## Important Commands Recap

```bash
# Create a container and publish port 80 as 8080
docker container create \
  --name container-a \
  --entrypoint sh \
  --net network-a \
  --publish 8080:80 \
  curlimages/curl

# Start the TCP server inside container-a
nc -l -p 80

# From container-b (after installing telnet), connect to gateway
telnet 172.18.0.1 8080

# From host machine (Linux only):
telnet localhost 8080

# Find gateway IP inside container
ip route
```

---

## Questions & Answers

### Q1: Why can’t containers on different networks ping each other?

**A:** Bridge networks are isolated by default in Docker. Inter-network
communication requires either:

- Using `docker network connect`
- Publishing ports and connecting via host gateway

---

### Q2: What does `8080:80` mean in Docker?

**A:** It's a **port mapping**. Port `8080` on the host maps to port `80` inside
the container.

---

### Q3: Why did Telnet initially hang?

**A:** Because the two containers were on separate networks and no port was
published from Container A.

---

### Q4: What if I get “port already allocated” error?

**A:** The host port (e.g., `8080`) is already used by another process. Choose a
different port or stop the conflicting service.

---

### Q5: Can I connect to a published port from my browser?

**A:** Yes. If you publish port 8080 and your container runs a web server,
visiting `http://localhost:8080` on your host browser will work (on Linux
directly, and on Mac/Windows via Docker Desktop’s proxy).

---
