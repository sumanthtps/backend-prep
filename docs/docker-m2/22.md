---

title: Customizing Your Docker Image with RUN
sidebar_position: 49
---------------------

## Introduction

After learning how to copy files into a Docker image with `COPY`, the next step is **customizing the image** using the `RUN` instruction. `RUN` is one of the most powerful Dockerfile instructions—it allows you to **install software**, **configure packages**, or **prepare the environment** inside your image.

---

## What Does `RUN` Do?

```dockerfile
RUN <command>
```

The `RUN` command:

- Executes shell commands **inside a temporary container**.
- Captures the **resulting file system changes** as a new **image layer**.
- Runs each command **in order** as per Dockerfile sequence.

> Think of it as automating the process of manually running commands inside a
> container shell, but saving the results into the image.

---

## How RUN Works Internally

Given this Dockerfile:

```dockerfile
FROM ubuntu
COPY . /app
RUN stat /app
```

Docker executes:

1. Use the `ubuntu` image (base layer).
2. Add a new layer with your local files under `/app`.
3. Create a temporary container from the above image and run `stat /app`.

This becomes a new layer that stores the outcome of the `RUN`.

### What If You Switch COPY and RUN?

```dockerfile
FROM ubuntu
RUN stat /app    # ❌ This will fail
COPY . /app
```

It fails because `/app` hasn’t been created yet! **Order matters** in
Dockerfiles.

---

## Two Forms of RUN

### 1. **Shell Form** (recommended for most cases)

```dockerfile
RUN apt -y update && apt -y install curl
```

- Runs the command in a shell (`/bin/sh -c`).
- Supports shell features: piping, chaining (`&&`), variable substitution, etc.
- Simpler and more readable.

### 2. **Exec Form** (more precise)

```dockerfile
RUN ["apt", "-y", "update"]
```

- Directly executes the binary (no shell).
- Preferred in `CMD` or `ENTRYPOINT` when you don’t want a shell process.
- Doesn’t support shell-specific syntax.

> For `RUN`, **shell form is usually preferred** since you often use `&&`,
> pipes, or environment variables.

---

## Example: Installing `curl`

### Dockerfile snippet:

```dockerfile
RUN apt -y update && apt -y install curl
```

- `apt -y update`: Refresh Ubuntu’s package index.
- `apt -y install curl`: Install `curl` without manual confirmation.
- `-y`: Automatically accept prompts.
- No need for `sudo` — containers run as **root** by default.

---

## Building the Updated Image

```bash
docker image build .
```

- Docker will now create a **new layer** representing the installation of
  `curl`.
- This may take time on the first run.
- Next builds will **reuse the cached layer** if nothing changed above it.

---

## Verifying Installation

```bash
docker run --rm <image-id> curl example.com
```

✅ If you get HTML output, `curl` was successfully installed in the image.

---

## Layer Caching in Action

Rebuild the image again without changes:

```bash
docker image build .
```

⚡ It will be **much faster** because Docker **reuses cached layers** (unless
something above the `RUN` line has changed).

---

## Summary

| Command                                    | Purpose                                                   |
| ------------------------------------------ | --------------------------------------------------------- |
| `RUN <cmd>`                                | Executes a shell command in a temporary container         |
| `RUN apt -y update && apt -y install curl` | Installs curl in the image using Ubuntu’s package manager |
| `docker image build .`                     | Builds the image and caches layers                        |
| `docker run --rm <id> curl example.com`    | Verifies that curl is installed and functional            |

---

## Best Practices

- **Use shell form** when combining commands with `&&`.
- **Group related commands** into one `RUN` to reduce the number of layers.
- Place **infrequently changed commands (like `apt update`) earlier** in the
  Dockerfile to take advantage of caching.

---

## Q\&A Section

### Q1: Why did we skip `sudo` while installing curl?

✅ Docker containers run as **root** by default, so `sudo` is not necessary.

---

### Q2: What happens if we switch the order of `COPY` and `RUN`?

❌ `RUN` will fail because the files you're trying to reference with `RUN`
haven't been copied yet.

---

### Q3: When should I use shell form vs exec form?

- ✅ Use **shell form** when using pipes, `&&`, variables.
- ✅ Use **exec form** when running a single binary **without a shell** (e.g.,
  for `CMD` or `ENTRYPOINT`).

---

### Q4: What does Docker cache?

✅ Docker caches **image layers**. If the contents of a layer haven't changed,
Docker reuses it to speed up builds.

---

### Q5: How can I verify if a command like `curl` was installed?

Run:

```bash
docker run --rm <image-id> curl example.com
```

If you see an HTML response, `curl` works inside your image.

---

Next: You’ll learn about `CMD`—how to configure what your container runs by
default when started.
