---

title: Multi-App Images in Docker
sidebar_position: 56
---------------------

## üß© What Are Multi-App Images?

### üí° Definition:

A **multi-app (multi-process) container** runs more than one application in a single Docker container instance.

---

## üö® Why It‚Äôs NOT Recommended by Default

Docker‚Äôs design philosophy favors:

- **One process per container**
- Better isolation
- Easy orchestration
- Faster restart and fault recovery

### üß® Problems with multi-app containers:

| Issue              | Why it's bad                                          |
| ------------------ | ----------------------------------------------------- |
| üßµ Signal handling | Signals (e.g., `SIGTERM`) may not reach all processes |
| üõ†Ô∏è Complex startup | Harder to troubleshoot or restart individual apps     |
| üß≠ Visibility      | `docker ps` won‚Äôt show which processes run inside     |
| üê¢ Slower startup  | Affects cloud elasticity and cost                     |
| üßº Cleanup issues  | One process may linger after main one exits           |

---

## üì¶ When You _Might_ Use Multi-App Containers

### ‚úÖ Legacy Systems

- Apps that tightly couple services
- Can‚Äôt split without breaking

### ‚úÖ Testing VMs (e.g., for Ansible)

- Emulate a VM environment without full virtualization

### ‚úÖ Simulated Clusters (e.g., `kind`)

- Run multiple Kubernetes components in 1 container
- Lightweight development use only

---

## üß∞ Better Alternatives

### 1. **Use multiple containers on the same Docker network**

Each app in its own container, connected via Docker's internal networking.

```bash
docker network create my-network

docker run -d --network my-network --name db postgres
docker run -d --network my-network --name api my-api
```

---

### 2. **Use Docker Compose**

Defines all services in one YAML file.

Example: `docker-compose.yml`

```yaml
version: "3"
services:
  db:
    image: postgres
  web:
    image: my-web-app
    depends_on:
      - db
```

> üìù Compose simplifies orchestration, especially for local development.

---

### 3. **Use a Container Orchestrator (e.g., Kubernetes)**

For distributed, scalable deployments across nodes.

> Tools like Kubernetes manage services, health, scaling, and recovery.

---

## üõ†Ô∏è Three Ways to Build Multi-App Images

### 1. **Entrypoint Script with Background Processes**

Dockerfile:

```Dockerfile
COPY entrypoint.sh /entrypoint.sh
ENTRYPOINT ["/entrypoint.sh"]
```

`entrypoint.sh`:

```bash
#!/bin/bash
my-first-process &
my-second-process &

wait -n  # Wait for any process to exit
exit $?  # Exit container with that process's status
```

> ‚ö†Ô∏è If not handled correctly, background processes might stay running even
> after the container is stopped.

---

### ‚úÖ Fix: Use `--init` to handle signals properly

```bash
docker run --init my-multi-app
```

- Uses `tini` as a **PID 1 supervisor**
- Ensures all subprocesses receive signals (like SIGTERM)
- Prevents zombie processes

---

### 2. **Using `systemd` in a Container**

**Not recommended** unless **absolutely necessary**

#### üß± Why it's hard:

- `systemd` manages everything: cgroups, DNS, network
- Conflicts with Docker‚Äôs internal systems

#### üß© Requires:

- Custom base images (e.g., `centos:7`)
- Volume mounts: `/sys/fs/cgroup`, `/run`, etc.
- Complex startup scripts

#### üîí Use case:

- You‚Äôre migrating unmodifiable apps that are systemd-bound

---

### 3. **Using `s6-overlay` (Recommended middle ground)**

#### What is `s6`?

- Lightweight process supervisor
- Built for containers
- Easier than systemd, more robust than `tini`

#### Features:

- Manages multiple services
- Signal forwarding
- Crash recovery

#### Example Dockerfile (from GitHub user `madewithlove`):

```Dockerfile
FROM madewithlove/s6-php-nginx

# s6 looks for services in /etc/services.d/
COPY nginx /etc/services.d/nginx
COPY php /etc/services.d/php
```

Each service folder contains a `run` script.

---

## üì∑ Visual Example

**Single App Container vs Multi-App Container**

| Type       | Example Apps | Architecture          |
| ---------- | ------------ | --------------------- |
| Single App | NGINX        | Dockerfile ‚Üí NGINX    |
| Multi-App  | PHP + NGINX  | Entrypoint ‚Üí Both run |

![Multi-App Container Image Example](https://miro.medium.com/v2/resize:fit:720/format:webp/1*FXF4KQKvbgrOCoxNHqzhzA.png)

---

## ‚ùì Questions and Answers

### Q1: Why is `--init` important?

Without it, signals sent to containers **may not reach child processes**,
leaving them running even after container exit. `--init` ensures clean shutdown
of all processes.

---

### Q2: Is using `systemd` inside a container a good idea?

Only as a **last resort**. It introduces high complexity, potential Docker
conflicts, and difficult troubleshooting.

---

### Q3: What makes `s6-overlay` better than `tini` or `systemd`?

| Feature          | tini | systemd   | s6-overlay |
| ---------------- | ---- | --------- | ---------- |
| Lightweight      | ‚úÖ   | ‚ùå        | ‚úÖ         |
| Multi-service    | ‚ùå   | ‚úÖ        | ‚úÖ         |
| Built for Docker | ‚úÖ   | ‚ùå        | ‚úÖ         |
| Setup difficulty | Easy | Very hard | Moderate   |

---

### Q4: Why avoid multi-app containers in cloud environments?

- Slower startup = **higher billing**
- Tougher to recover/scale individual services
- Harder to monitor and debug

---

## üß† Key Takeaways

- Containers are designed for **one app per container**
- Use **multi-app** containers only when:

  - Dealing with legacy apps
  - Simulating VMs or test environments

- Use tools like:

  - `--init` for process supervision
  - `s6-overlay` for clean multi-process handling
  - Docker Compose or Kubernetes for cleaner alternatives

---
