---

title: Starting Your App with ENTRYPOINT
sidebar_position: 50
---------------------

## Introduction

To build useful Docker images, it's not enough to just copy files and install packages. You must also tell Docker **what to execute** when a container starts from your image.

This is where the `ENTRYPOINT` instruction comes in.

---

## Why Use ENTRYPOINT?

- `ENTRYPOINT` defines **the main command** that will always run when a
  container is started from the image.
- Think of it as the "**main function**" of your Docker image.
- It replaces the default behavior of the base image (which may run `/bin/bash`
  or something else).

Without setting an `ENTRYPOINT`, containers created from your image will behave
like the base image, which may not execute your app.

---

## ENTRYPOINT vs CMD: Quick Overview

| Feature           | ENTRYPOINT                          | CMD                                      |
| ----------------- | ----------------------------------- | ---------------------------------------- |
| Purpose           | Defines the main application to run | Provides default arguments to ENTRYPOINT |
| Can be overridden | No (unless `--entrypoint` is used)  | Yes                                      |
| Best for          | Mandatory startup commands          | Optional/default flags or inputs         |
| Common form       | Exec form (`["/app/app.sh"]`)       | String or exec form                      |

We’ll later learn how `CMD` and `ENTRYPOINT` work **together**.

---

## Forms of ENTRYPOINT

There are two forms:

### 1. **Shell Form**

```dockerfile
ENTRYPOINT /app/app.sh
```

- Runs the command via `/bin/sh -c`.
- Your app becomes **child process** of the shell.
- Problems:

  - Signals (e.g., Ctrl+C) go to the shell, **not your app**.
  - Arguments passed via `docker run` go to the shell instead of your app.

- ✅ Pros: Supports shell features like pipes, variable substitution.
- ❌ Cons: **Signals and args don’t go to your app**. Bad for production use.

### 2. **Exec Form (Recommended)**

```dockerfile
ENTRYPOINT ["/app/app.sh"]
```

- App becomes the **PID 1 (top-level process)**.
- Arguments passed with `docker run` go directly to your app.
- Signals like `SIGINT` go directly to your app.
- ✅ Best practice for long-running apps or any command that needs clean
  termination.

---

## Example: App that Displays Time, Processes, and Args

Suppose we have a simple Bash script `app.sh` that:

- Uses `curl` to fetch internet time.
- Lists running processes.
- Prints received arguments.

### Dockerfile with ENTRYPOINT (Shell Form)

```dockerfile
FROM ubuntu
COPY . /app
RUN apt -y update && apt -y install curl
ENTRYPOINT /app/app.sh
```

When built and run like:

```bash
docker build -t my-image .
docker run --rm my-image --debug
```

**What happens:**

- `--debug` is passed to `/bin/sh`, not to `app.sh`.
- Signals (like Ctrl+C) are also handled by the shell, not your script.
- Inside the container:

  - Your script's parent PID is **`sh`**, not `init` or `PID 1`.
  - Your script does **not** receive the arguments.

---

### Switch to Exec Form

```dockerfile
ENTRYPOINT ["/app/app.sh"]
```

Build and run again:

```bash
docker build -t my-image .
docker run --rm my-image --debug
```

**Now:**

- `--debug` goes to your app.
- Your app becomes **PID 1**.
- Proper signal handling and graceful shutdown.
- Your app prints the argument correctly.

---

## Entrypoint Script Pattern

Sometimes you want both:

- Complex logic (e.g., init steps, pipes, env vars).
- Correct signal/argument handling.

Use a **shell script** for complex logic and call it via **exec form**.

### Dockerfile

```dockerfile
COPY entrypoint.sh /entrypoint.sh
ENTRYPOINT ["/entrypoint.sh"]
```

### entrypoint.sh

```bash
#!/bin/bash
# setup logic here (env vars, pipes, etc.)

exec "$@"  # hand off to your actual app (preserves PID 1 and signals)
```

This pattern allows:

- Reuse of shell scripting power.
- Proper behavior via `exec`.

---

## Naming the Image

Tired of using image IDs like `abc1234`?

Use the `-t` (tag) option during `docker build`:

```bash
docker build -t my-image .
```

Now you can run:

```bash
docker run --rm my-image --debug
```

✅ Much easier to remember and use.

---

## Summary

| Concept                   | Details                                                       |
| ------------------------- | ------------------------------------------------------------- |
| `ENTRYPOINT`              | Defines the primary command for the container.                |
| Shell form                | Easy, but intercepts signals and args. Avoid in production.   |
| Exec form                 | Clean handling of signals and arguments. Preferred.           |
| Entrypoint script pattern | Write a shell script for logic, then use exec form to run it. |
| `docker build -t`         | Tag your image for easier usage.                              |

---

## Questions and Answers

### Q1: Why didn't my app receive `--debug`?

Because you used shell form:

```dockerfile
ENTRYPOINT /app/app.sh
```

The shell intercepted the argument instead of passing it to your app.

---

### Q2: How can I make sure my app gets Ctrl+C signals?

Use **exec form**:

```dockerfile
ENTRYPOINT ["/app/app.sh"]
```

Now your app is PID 1 and will handle signals.

---

### Q3: Can I use environment variables or pipes in `ENTRYPOINT`?

Yes, but only in **shell form** or via **entrypoint script pattern**:

```bash
#!/bin/bash
# inside entrypoint.sh
echo "ENV=$MY_ENV"
exec "$@"
```

---

### Q4: When would I use `--entrypoint` in `docker run`?

To override the default `ENTRYPOINT`:

```bash
docker run --entrypoint /bin/bash my-image
```

This is helpful for debugging.

---

### Q5: Can I combine `CMD` and `ENTRYPOINT`?

Yes!

```dockerfile
ENTRYPOINT ["/app/app.sh"]
CMD ["--debug"]
```

- If you run: `docker run my-image`, `--debug` is passed to `app.sh`.
- If you run: `docker run my-image --help`, `--help` overrides CMD.

---

ENTRYPOINT ensures your container runs **exactly what you want**, every time,
with proper signal and argument handling. When used with `CMD`, it creates a
flexible and powerful launch configuration.
