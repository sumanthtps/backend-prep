---
id: installing-docker-in-container
title: Installing Docker in the Container of Containers
sidebar_position: 66
---

## Summary

In this section, we **install the Docker CLI inside a container** that already
has access to the hostâ€™s Docker daemon (via socket binding). This enables full
**Docker-in-Docker (DooD)** functionality â€” the container can now issue Docker
commands using the host's Docker engine.

---

## Key Concepts

### ğŸ³ Why Install Docker in the Container?

Although we already mounted `/var/run/docker.sock` (the Docker UNIX socket) from
the host into our container in the last step, the container **doesn't have the
Docker CLI binary (`docker`) yet**.

We need the CLI so we can run commands like:

```bash
docker ps
docker run --rm my-image
```

````

---

### ğŸ”§ Installing Docker CLI Inside the Container

You can install the Docker CLI by running:

```bash
curl -L get.docker.io | bash
```

> ğŸ› ï¸ This script installs both the Docker **client** and **engine**, but since
> weâ€™ve mounted the hostâ€™s Docker socket, only the **client** is needed and
> used.

---

### âœ… Verifying the Setup

Once installed:

```bash
docker ps
```

You will see:

- Your own container running
- Any other host containers (e.g. Portainer, app containers)

---

## ğŸ¯ Docker-in-Docker in Action

Now that the container has:

- Access to the Docker socket
- The Docker CLI installed

â€¦it can now run containers itself.

```bash
docker run --rm my-image
```

This command:

- Runs a new container **from inside** the current container
- The new container is actually managed **by the host's Docker daemon**

---

## ğŸ“Œ Important Notes

### ğŸ§± Applications That Use Docker API

- Many tools (e.g. CI/CD systems, job runners) interact with Docker via the
  **Docker Engine API**.
- Once the Docker CLI is installed and the socket is mounted, any app inside the
  container can:

  - List containers
  - Create and start containers
  - Remove containers
  - Pull/push images
  - Access volume/network endpoints

ğŸ’¡ These operations work because the app talks to the **host Docker daemon** via
the mounted socket.

---

## ğŸ–¼ï¸ Image Explanation

![Docker-in-Docker with CLI](https://raw.githubusercontent.com/docker/labs/master/bind-mounting/docker-in-docker-socket.png)
_Image Source: [Docker Labs GitHub](https://github.com/docker/labs)_

- ğŸ”µ Host system runs the actual Docker engine
- ğŸŸ¡ A container mounts `/var/run/docker.sock`
- ğŸŸ¢ Docker CLI in the container sends commands to the host engine
- ğŸ” The host engine spawns sibling containers on request

---

## MCQ-Style Questions

### ğŸ“Œ Q1: Why do we install the Docker client inside the container?

A. To run Docker commands like `docker ps` from inside the container B. To
isolate the Docker daemon from the host C. Because bind mounts wonâ€™t work
without Docker installed D. To support Kubernetes control plane

**âœ… Correct Answer:** A

**Explanation:**

- The Docker CLI lets the container issue commands to the host Docker engine via
  the mounted UNIX socket.

---

### ğŸ“Œ Q2: What does the command `curl -L get.docker.io | bash` do?

A. Downloads only the Docker engine B. Downloads and installs the Docker CLI and
engine C. Installs Kubernetes D. Mounts the Docker socket into the container

**âœ… Correct Answer:** B

**Explanation:**

- This installs both the CLI and engine, though in our case only the CLI is
  used.

---

### ğŸ“Œ Q3: What will happen if you run `docker ps` inside the container after mounting `/var/run/docker.sock` and installing the CLI?

A. You'll only see processes inside the container B. You'll see the host system
processes C. You'll see all containers managed by the host's Docker engine D.
The command will fail due to missing privileges

**âœ… Correct Answer:** C

**Explanation:**

- Because the CLI is querying the host Docker engine through the socket, it
  returns the host's container list.

---

## Conclusion

You've now completed the core setup for **Docker-in-Docker using the hostâ€™s
Docker engine**. With the socket mount and Docker CLI installed, your container
becomes a **Docker controller** capable of launching and managing sibling
containers â€” perfect for automation, CI/CD, and platform tooling.

---
````
