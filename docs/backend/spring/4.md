### **What Happens in the Background? (Spring Debug Logs & Dependency Management)**  

In this step, we explore **how Spring Framework identifies components, wires dependencies, and handles errors**. We also analyze Spring's debug logs to understand its **Inversion of Control (IoC) process**.

---

## **1Ô∏è‚É£ Enabling Debug Logs in Spring Boot**  
By default, Spring logs **only INFO-level messages**. To see more details, we set the **logging level to DEBUG** in `application.properties`.

üìå **Update `src/main/resources/application.properties`**  
```properties
logging.level.org.springframework=DEBUG
```
Now, when we **run the application**, we get **detailed logs** showing how Spring **creates and injects beans**.

---

## **2Ô∏è‚É£ Debug Logs: Understanding Component Scanning & Dependency Injection**  
When we run our Spring Boot application, we see logs like:

```
Identified candidate component class: file [MarioGame.class]
Identified candidate component class: file [GameRunner.class]
Creating shared instance of singleton bean 'gameRunner'
Autowiring by type from bean name 'gameRunner' via constructor to bean named 'marioGame'
```

### **What‚Äôs Happening Here?**
1Ô∏è‚É£ **Spring scans for `@Component`-annotated classes.**  
   - It finds `MarioGame` and `GameRunner`, so **they become Spring-managed beans**.

2Ô∏è‚É£ **Spring creates an instance (bean) of `MarioGame`.**  
   - **By default, beans in Spring are SINGLETONS**, meaning only **one instance** is created.

3Ô∏è‚É£ **Spring auto-wires the `MarioGame` bean into `GameRunner`'s constructor.**  
   - `GameRunner` has a dependency on `GamingConsole` (interface).
   - Spring finds that `MarioGame` **implements** `GamingConsole`, so it injects it automatically.

---

## **3Ô∏è‚É£ Experimenting with Component Scanning**
### **üîπ What Happens If We Remove `@Component` from `MarioGame`?**
If we **remove** `@Component` from `MarioGame`, Spring will **fail** to find a bean for `GamingConsole`:
```
UnsatisfiedDependencyException: No qualifying bean of type 'GamingConsole' available
```
Spring says:
```
Consider defining a bean of type 'GamingConsole' in your configuration.
```
üìå **Fix:** Add `@Component` back to `MarioGame`:
```java
@Component
class MarioGame implements GamingConsole { ... }
```

---

### **üîπ What Happens If We Have Multiple Implementations?**
If we **add `@Component`** to multiple classes (`PacManGame`, `SuperContraGame`), Spring gets **confused**:
```
NoUniqueBeanDefinitionException: No qualifying bean of type 'GamingConsole' available:
expected single matching bean but found 2: pacManGame, superContraGame
```
Spring tells us:
```
Consider marking one of them as @Primary
```
üìå **Fix 1: Mark One as `@Primary`**
```java
@Component
@Primary // This will be the default GamingConsole
class MarioGame implements GamingConsole { ... }
```

üìå **Fix 2: Use `@Qualifier` to Specify the Bean Explicitly**
```java
@Autowired
public GameRunner(@Qualifier("pacManGame") GamingConsole game) { 
    this.game = game; 
}
```

---

## **4Ô∏è‚É£ Understanding Spring Beans & Dependency Management**
| **Concept** | **Description** |
|------------|----------------|
| **Spring Bean** | An object managed by Spring (created automatically). |
| **Component Scanning** | Spring scans for `@Component` classes and registers them. |
| **Dependency Injection (DI)** | Automatically injects dependencies (`@Autowired`). |
| **Singleton Scope** | By default, Spring beans are **singletons** (one instance per context). |
| **`@Primary` Annotation** | Marks a bean as the default when multiple implementations exist. |
| **`@Qualifier` Annotation** | Explicitly specifies which bean to use when multiple exist. |

---

## **5Ô∏è‚É£ Summary of Key Learnings**
‚úÖ **Spring scans `@Component` classes and creates beans automatically.**  
‚úÖ **Spring injects dependencies using `@Autowired` (via constructor injection).**  
‚úÖ **If no bean is found, Spring throws `UnsatisfiedDependencyException`.**  
‚úÖ **If multiple beans are found, Spring throws `NoUniqueBeanDefinitionException`.**  
‚úÖ **Use `@Primary` or `@Qualifier` to resolve multiple beans.**  

---

### **üöÄ Next Steps**
Now that we understand **how Spring manages dependencies**, do you want to:  
1Ô∏è‚É£ **Explore `@Configuration` and `@Bean` for manual bean creation?**  
2Ô∏è‚É£ **Learn how to use Spring Profiles for different configurations?**  
3Ô∏è‚É£ **Understand Prototype vs Singleton Bean Scopes?**  

Let me know what you‚Äôd like to dive into next! üöÄ