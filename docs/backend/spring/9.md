### **Different Types of Dependency Injection in Spring**  
Spring provides **three types of dependency injection**:  
1ï¸âƒ£ **Constructor Injection** (âœ… Recommended)  
2ï¸âƒ£ **Setter Injection**  
3ï¸âƒ£ **Field Injection**  

In this step, we will explore **each type**, understand **why constructor injection is preferred**, and practice converting field injection to constructor injection.

---

## **1ï¸âƒ£ Constructor Injection (Recommended âœ…)**
ğŸ“Œ **How It Works:**  
- Dependencies are **provided via the constructor**.
- Ensures **all required dependencies are available** when the object is created.
- Recommended by **Spring Team** for better **immutability** and **testability**.

ğŸ“Œ **Example: Constructor Injection in `BusinessService`**
```java
@Component
public class BusinessService {

    private final DataService dataService;

    @Autowired
    public BusinessService(DataService dataService) {  // Inject dependency via constructor
        this.dataService = dataService;
        System.out.println("Constructor Injection");
    }

    public int calculateSum() {
        return dataService.getData().stream().reduce(Integer::sum).orElse(0);
    }
}
```
âœ… **Advantages of Constructor Injection:**  
âœ” **Mandatory dependencies are always set** at object creation.  
âœ” **Best for immutability** (no need for `setters`).  
âœ” **Easier for unit testing** (you can pass mock dependencies).  

---

## **2ï¸âƒ£ Setter Injection**
ğŸ“Œ **How It Works:**  
- Dependencies are **provided via setter methods**.
- Allows setting dependencies **after object creation**.

ğŸ“Œ **Example: Setter Injection in `BusinessService`**
```java
@Component
public class BusinessService {

    private DataService dataService;

    @Autowired
    public void setDataService(DataService dataService) { // Inject dependency via setter
        this.dataService = dataService;
        System.out.println("Setter Injection");
    }

    public int calculateSum() {
        return dataService.getData().stream().reduce(Integer::sum).orElse(0);
    }
}
```
âœ… **Advantages of Setter Injection:**  
âœ” **Useful when dependencies are optional**.  
âœ” **Allows modifying dependencies at runtime**.  

âŒ **Disadvantages:**  
- Not ideal for **mandatory dependencies**.  
- **Setter methods can be overridden**, causing unintended behavior.  

---

## **3ï¸âƒ£ Field Injection (Not Recommended âŒ)**
ğŸ“Œ **How It Works:**  
- The `@Autowired` annotation is **directly placed on the field**.  
- **Uses reflection** to inject dependencies.  

ğŸ“Œ **Example: Field Injection in `BusinessService`**
```java
@Component
public class BusinessService {

    @Autowired
    private DataService dataService; // Injected directly

    public int calculateSum() {
        return dataService.getData().stream().reduce(Integer::sum).orElse(0);
    }
}
```
âŒ **Disadvantages of Field Injection:**  
- **Not testable** (Cannot pass mocks easily).  
- **Encourages mutable state** (not good for thread safety).  
- **Hides dependencies** (less readable).  

ğŸ”´ **Why Avoid Field Injection?**
Field injection **cannot be used for immutable objects**, and **you cannot easily test it** by providing mock dependencies.

---

## **4ï¸âƒ£ Which Dependency Injection Type Should You Use?**
| **Injection Type** | **Recommended?** | **Pros** | **Cons** |
|------------------|----------------|----------|---------|
| **Constructor Injection** | âœ… Yes (Preferred) | Ensures all dependencies are set, better testability, immutability | Requires more boilerplate code |
| **Setter Injection** | âš ï¸ Sometimes | Good for optional dependencies | Allows modification at runtime, not ideal for required dependencies |
| **Field Injection** | âŒ No | Shorter code | Hard to test, less readable |

ğŸ“Œ **Best Practice:** **Always use Constructor Injection unless you have optional dependencies.**  

---

## **5ï¸âƒ£ Exercise: Convert Field Injection to Constructor Injection in `MyWebController`**
ğŸ“Œ **Current Code (Using Field Injection)**
```java
@Component
public class MyWebController {

    @Autowired
    private BusinessService businessService; // Field Injection âŒ

    public long returnValueFromBusinessService() {
        return businessService.calculateSum();
    }
}
```
ğŸ”´ **Problem:**  
- **Field Injection is discouraged** because it makes testing difficult.  

âœ… **Convert it to Constructor Injection:**
```java
@Component
public class MyWebController {

    private final BusinessService businessService;

    @Autowired
    public MyWebController(BusinessService businessService) { // Constructor Injection âœ…
        this.businessService = businessService;
        System.out.println("Constructor Injection in MyWebController");
    }

    public long returnValueFromBusinessService() {
        return businessService.calculateSum();
    }
}
```
ğŸ“Œ **Run the application and check the logs.** You should see:
```
Constructor Injection in MyWebController
```
âœ” **Congratulations! You successfully converted Field Injection to Constructor Injection!** ğŸ‰  

---

## **6ï¸âƒ£ Summary**
| **Concept** | **Description** |
|------------|----------------|
| **Constructor Injection** âœ… | **Preferred method**. Ensures all dependencies are set at object creation. |
| **Setter Injection** âš ï¸ | Used when dependencies are **optional**. Allows modification at runtime. |
| **Field Injection** âŒ | **Not recommended**. Hard to test, hides dependencies, and relies on reflection. |

---

## **7ï¸âƒ£ Next Steps ğŸš€**
Would you like to:  
1ï¸âƒ£ **Learn how to handle optional dependencies (`@Autowired(required=false)`)**?  
2ï¸âƒ£ **Explore Spring Bean Scopes (`Singleton`, `Prototype`, etc.)?**  
3ï¸âƒ£ **Understand Circular Dependencies in Spring & how to fix them?**  

Let me know what you'd like to learn next! ğŸš€